<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="When there is a will, there is a way.">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      linux 基础实验 | GENIA
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>GENIA</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>linux 基础实验</h2>
  <p class="post-date">2023-12-08</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="小实验记录"><a href="#小实验记录" class="headerlink" title="小实验记录"></a>小实验记录</h1><p>阅读过程中发现了一些好玩的实操部分，正好提供了部分源码供下载就试试看。图一乐。</p>
<p>我的 ubuntu20.04 只有双核，多核实验具有局限性。另外虚拟机的实验结果和实机系统有一些微小的差异，不过我觉得可以忽略不计。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="strace-命令"><a href="#strace-命令" class="headerlink" title="strace 命令"></a>strace 命令</h3><p>以 hello.c 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>strace 命令可以追踪查看程序使用了哪些系统调用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">-non-kernel-os$ </span><span class="language-bash">strace -o hello.log ./hello</span></span><br><span class="line">hello world</span><br><span class="line">giantbranch@ubuntu:~/Desktop/【实验程序】linux-in-practice-master/02-syscall-and</span><br><span class="line"><span class="meta prompt_">-non-kernel-os$ </span><span class="language-bash"><span class="built_in">cat</span> hello.log</span></span><br><span class="line">execve(&quot;./hello&quot;, [&quot;./hello&quot;], [/* 60 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0x1875000</span><br><span class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=95961, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 95961, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f8d73c61000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0`\t\2\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1868984, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f8d73c60000</span><br><span class="line">mmap(NULL, 3971488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f8d7368a000</span><br><span class="line">mprotect(0x7f8d7384a000, 2097152, PROT_NONE) = 0</span><br><span class="line">mmap(0x7f8d73a4a000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c0000) = 0x7f8d73a4a000</span><br><span class="line">mmap(0x7f8d73a50000, 14752, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f8d73a50000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f8d73c5f000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f8d73c5e000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7f8d73c5f700) = 0</span><br><span class="line">mprotect(0x7f8d73a4a000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x600000, 4096, PROT_READ)     = 0</span><br><span class="line">mprotect(0x7f8d73c79000, 4096, PROT_READ) = 0</span><br><span class="line">munmap(0x7f8d73c61000, 95961)           = 0</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 4), ...&#125;) = 0</span><br><span class="line">brk(NULL)                               = 0x1875000</span><br><span class="line">brk(0x1896000)                          = 0x1896000</span><br><span class="line">write(1, &quot;hello world\n&quot;, 12)           = 12</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure>

<p>每一行对应一个系统调用，大部分都是在main函数之前或之后执行的程序的开始和终止处理发起的（os提供的功能）。</p>
<p>无论使用何种语言编写的程序，都必须通过系统调用向内核发起请求，这一点可以用 python 进行试验：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/【实验程序】linux-in-practice-master/02-syscall-and</span><br><span class="line"><span class="meta prompt_">-non-kernel-os$ </span><span class="language-bash"><span class="built_in">cat</span> hello.py</span></span><br><span class="line">print(&quot;hello world&quot;)</span><br><span class="line">giantbranch@ubuntu:~/Desktop/【实验程序】linux-in-practice-master/02-syscall-and</span><br><span class="line"><span class="meta prompt_">-non-kernel-os$ </span><span class="language-bash">strace -o hello.py.log python3 ./hello.py</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>输出内容比上一次 strace 多得多（应该是python解析器的调用），但是有关 main 函数的主要系统调用还是那么几行。</p>
<p>另外，在 strace 命令后加上 -T 选项能够以很高的精度捕捉到每一种系统调用所消耗的时间， -tt 选项能够显示每一种内核处理发生的时刻。</p>
<h3 id="sar-命令"><a href="#sar-命令" class="headerlink" title="sar 命令"></a>sar 命令</h3><p>需要安装 sysstat 软件包：<a target="_blank" rel="noopener" href="https://www.yundongfang.com/Yun4290.html">如何在 Ubuntu 20.04 LTS 上安装 SysStat-云东方 (yundongfang.com)</a></p>
<p>用于获取进程分别在用户模式与内核模式下运行的时间比例。我们指定采集信息的周期与次数（分别为一次）：</p>
<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/sar%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8.png" class="">

<p>我的 ubuntu20.4 虚拟机设置了双核心，因此这里的 CPU 核心索引为 0-1。</p>
<p>%user 和 %nice 字段相加为进程在用户模式下运行的时间比例。</p>
<p>%system 则是在内核模式下执行系统调用等处理所占的时间比例。</p>
<p>在这里我没有运行任何程序，CPU 处于完全的空闲状态。</p>
<p>sar 命令还可以监测进程在各模式下的运行时间：</p>
<p>写一个无限循环 loop.c 进行测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">		;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后运行，再用 sar 监测：</p>
<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/loop.png" class="">

<p>可以猜出进程始终通过 CPU-0 运行，且一直在用户模式下运行。单纯的 for 循环不涉及系统调用 0_0</p>
<p>kill 当前进程。</p>
<p>改写一下循环，加入一个函数再进行测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">		getppid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/ppidloop.png" class="">

<p>很明显修改后的程序在运行过程中内核处理的时间大大增加。</p>
<h3 id="ldd-命令"><a href="#ldd-命令" class="headerlink" title="ldd 命令"></a>ldd 命令</h3><p>可以查看程序所依赖的库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">teriteri@ubuntu:~/Desktop/【实验程序】linux-in-practice-master/02-syscall-and-no</span><br><span class="line"><span class="meta prompt_">n-kernel-os$ </span><span class="language-bash">ldd /bin/echo</span></span><br><span class="line">	linux-vdso.so.1 (0x00007fffcd1f1000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff7bf4d9000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007ff7bf6e8000)</span><br><span class="line">teriteri@ubuntu:~/Desktop/【实验程序】linux-in-practice-master/02-syscall-and-no</span><br><span class="line"><span class="meta prompt_">n-kernel-os$ </span><span class="language-bash">ldd /usr/bin/python3</span></span><br><span class="line">	linux-vdso.so.1 (0x00007ffd93136000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdf61e2b000)</span><br><span class="line">	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fdf61e08000)</span><br><span class="line">	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fdf61e02000)</span><br><span class="line">	libutil.so.1 =&gt; /lib/x86_64-linux-gnu/libutil.so.1 (0x00007fdf61dfd000)</span><br><span class="line">	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fdf61cae000)</span><br><span class="line">	libexpat.so.1 =&gt; /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007fdf61c80000)</span><br><span class="line">	libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007fdf61c62000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007fdf6202f000)</span><br></pre></td></tr></table></figure>

<p>可见 python3 本身的实现同样依赖于 libc。</p>
<p>在 OS 层面上，C语言发挥着巨大的作用。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>调用 fork() 函数，基于发起调用的进程（父进程），创建一个新的进程（子进程）。</p>
<p>调用流程大概可以这么概括：</p>
<ul>
<li>为子进程申请内存空间，把父进程的内存复制到新的内存空间。</li>
<li>父进程与子进程分裂为两个进程，分别执行不同代码。因为 fork() 函数返回了不同的值给父进程与子进程。</li>
</ul>
<p>通过 fork.c 进行实验：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">child</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child! my pid is %d.\n&quot;</span>, getpid());</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parent</span><span class="params">(<span class="type">pid_t</span> pid_c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent! my pid is %d and the pid of my child is %d.\n&quot;</span>,</span><br><span class="line">	       getpid(), pid_c);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> ret;</span><br><span class="line">	ret = fork();</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">		err(EXIT_FAILURE, <span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// fork() 会返回 0 给子进程，因此这里调用 child()</span></span><br><span class="line">		child();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// fork() 会返回新创建的子进程的进程 ID（大于 1）给父进程，因此这里调用 parent()</span></span><br><span class="line">		parent(ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在正常运行时，不可能运行到这里</span></span><br><span class="line">	err(EXIT_FAILURE, <span class="string">&quot;shouldn&#x27;t reach here&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/fork.png" class="">

<p>两个进程都得到了各自的结果。</p>
<h3 id="execve"><a href="#execve" class="headerlink" title="execve()"></a>execve()</h3><p>用于启动一个进程，流程大概如下：</p>
<ul>
<li>读取可执行文件，并读取创建进程的内存映像所需信息（ELF文件内容）</li>
<li>用新进程的数据覆盖当前进程的内存</li>
<li>从最初的命令开始运行新的进程</li>
</ul>
<p>以 fork-and-exec.c 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">child</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *args[] = &#123; <span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;hello&quot;</span> , <span class="literal">NULL</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child! my pid is %d.\n&quot;</span>, getpid());</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	execve(<span class="string">&quot;/bin/echo&quot;</span>, args, <span class="literal">NULL</span>);</span><br><span class="line">	err(EXIT_FAILURE, <span class="string">&quot;exec() failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parent</span><span class="params">(<span class="type">pid_t</span> pid_c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent! my pid is %d and the pid of my child is %d.\n&quot;</span>,</span><br><span class="line">	       getpid(), pid_c);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> ret;</span><br><span class="line">	ret = fork();</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">		err(EXIT_FAILURE, <span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// fork() 会返回 0 给子进程，因此这里调用 child()</span></span><br><span class="line">		child();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// fork() 会返回新创建的子进程的进程 ID（大于 1）给父进程，因此这里调用 parent()</span></span><br><span class="line">		parent(ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在正常运行时，不可能运行到这里</span></span><br><span class="line">	err(EXIT_FAILURE, <span class="string">&quot;shouldn&#x27;t reach here&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/fork_and_exec.png" class="">

<p>新进程取代了原来 fork() 生成的子进程。</p>
<h2 id="进程调度器"><a href="#进程调度器" class="headerlink" title="进程调度器"></a>进程调度器</h2><h3 id="单核心多进程实验"><a href="#单核心多进程实验" class="headerlink" title="单核心多进程实验"></a>单核心多进程实验</h3><p>同时运行一个或多个单纯消耗 CPU 计算量的进程，记录</p>
<p>1.不同时间点运行的进程是哪个</p>
<p>2.每个进程的运行进度</p>
<p>源码 sched.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLOOP_FOR_ESTIMATION 1000000000UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSECS_PER_MSEC 1000000UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSECS_PER_SEC 1000000000UL</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> nloop_per_resol;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个timespec值之间的差值（以纳秒为单位）</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="title function_">diff_nsec</span><span class="params">(<span class="keyword">struct</span> timespec before, <span class="keyword">struct</span> timespec after)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((after.tv_sec * NSECS_PER_SEC + after.tv_nsec) - (before.tv_sec * NSECS_PER_SEC + before.tv_nsec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 估计执行一个毫秒所需的循环迭代次数</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">estimate_loops_per_msec</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">before</span>, <span class="title">after</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;before);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NLOOP_FOR_ESTIMATION; i++)</span><br><span class="line">        ; <span class="comment">// 空循环以消耗一定时间</span></span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;after);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">return</span> NLOOP_FOR_ESTIMATION * NSECS_PER_MSEC / diff_nsec(before, after);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一些CPU负载，通过执行循环迭代</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">load</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nloop_per_resol; i++)</span><br><span class="line">        ; <span class="comment">// 循环迭代以模拟CPU负载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个子进程执行的函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">child_fn</span><span class="params">(<span class="type">int</span> id, <span class="keyword">struct</span> timespec *buf, <span class="type">int</span> nrecord)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nrecord; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line"></span><br><span class="line">        load(); <span class="comment">// 模拟一些CPU负载</span></span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;ts); <span class="comment">// 记录当前时间</span></span><br><span class="line">        buf[i] = ts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nrecord; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印子进程ID、从开始到当前时间的时间差（以毫秒为单位）以及完成百分比</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%d\n&quot;</span>, id, diff_nsec(start, buf[i]) / NSECS_PER_MSEC, (i + <span class="number">1</span>) * <span class="number">100</span> / nrecord);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS); <span class="comment">// 终止子进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pid_t</span> *pids;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = EXIT_FAILURE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;nproc&gt; &lt;total[ms]&gt; &lt;resolution[ms]&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nproc = atoi(argv[<span class="number">1</span>]);  <span class="comment">//同时运行的程序数量  1、2、4</span></span><br><span class="line">    <span class="type">int</span> total = atoi(argv[<span class="number">2</span>]);  <span class="comment">//程序运行的总时长  100、100、100</span></span><br><span class="line">    <span class="type">int</span> resol = atoi(argv[<span class="number">3</span>]);  <span class="comment">//采集统计信息的间隔  1、1、1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nproc &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&lt;nproc&gt;(%d) should be &gt;= 1\n&quot;</span>, nproc);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (total &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&lt;total&gt;(%d) should be &gt;= 1\n&quot;</span>, total);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resol &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&lt;resol&gt;(%d) should be &gt;= 1\n&quot;</span>, resol);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (total % resol)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&lt;total&gt;(%d) should be multiple of &lt;resolution&gt;(%d)\n&quot;</span>, total, resol);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nrecord = total / resol; <span class="comment">// 每个进程要创建的记录数</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">logbuf</span> =</span> <span class="built_in">malloc</span>(nrecord * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> timespec));</span><br><span class="line">    <span class="keyword">if</span> (!logbuf)</span><br><span class="line">        err(EXIT_FAILURE, <span class="string">&quot;failed to allocate log buffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;estimating the workload which takes just one milli-second...&quot;</span>);</span><br><span class="line">    nloop_per_resol = estimate_loops_per_msec() * resol; <span class="comment">// 计算每个resolution所需的循环次数</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;end estimation&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    pids = <span class="built_in">malloc</span>(nproc * <span class="keyword">sizeof</span>(<span class="type">pid_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (pids == <span class="literal">NULL</span>)</span><br><span class="line">        err(EXIT_FAILURE, <span class="string">&quot;failed to allocate pid table&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start); <span class="comment">// 记录开始时间</span></span><br><span class="line"></span><br><span class="line">    ret = EXIT_SUCCESS;</span><br><span class="line">    <span class="type">int</span> i, ncreated;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, ncreated = <span class="number">0</span>; i &lt; nproc; i++, ncreated++)</span><br><span class="line">    &#123;</span><br><span class="line">        pids[i] = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="keyword">if</span> (pids[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ncreated; j++)</span><br><span class="line">                kill(pids[j], SIGKILL); <span class="comment">// 如果fork失败，kill创建的所有子进程</span></span><br><span class="line">            ret = EXIT_FAILURE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pids[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            child_fn(i, logbuf, nrecord); <span class="comment">// 执行子进程函数</span></span><br><span class="line">            <span class="comment">/* 不应该运行到这里 */</span></span><br><span class="line">            <span class="built_in">abort</span>(); <span class="comment">// 这应该永远不会被执行；在出现错误时中止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ncreated; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait(<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            warn(<span class="string">&quot;wait() failed.&quot;</span>); <span class="comment">// 等待所有子进程完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(ret); <span class="comment">// 以适当的退出状态终止主进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 OS 提供的 taskset 命令可以使程序在指定的逻辑 CPU 上运行，便于观察实验结果。同时将每次输出保存在另外的文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">taskset -c 0 ./sched 参数1 参数2 参数3 &gt;输出文件名.txt</span></span><br></pre></td></tr></table></figure>

<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.png" class="">

<p>可以自己用 matplotlib 为每组数据分别做两张点阵图，一张是在单核 CPU 上运行的进程（x：开始运行后经过的时间，y：进程 ID），一张表示各进程的进度（x：开始运行后经过的时间，y：进度）。</p>
<h4 id="单核单进程"><a href="#单核单进程" class="headerlink" title="单核单进程"></a>单核单进程</h4><img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/1core-1process.txt_1.png" class="">


<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/1core-1process.txt_2.png" class="">

<h4 id="单核双进程"><a href="#单核双进程" class="headerlink" title="单核双进程"></a>单核双进程</h4><img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/1core-2process.txt_1.png" class="">

<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/1core-2process.txt_2.png" class="">

<h4 id="单核四进程"><a href="#单核四进程" class="headerlink" title="单核四进程"></a>单核四进程</h4><img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/1core-4process.txt_1.png" class="">

<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/1core-4process.txt_2.png" class="">

<h4 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h4><ol>
<li>当只有一核 CPU 工作时，不管同时运行多少个进程，在任意一个时间点上只能有一个进程运行</li>
<li>当一核 CPU 需要运行多个进程时，它们将按轮询调度的方式循环运行，所有进程按顺序逐个运行，不断循环直至所有进程结束</li>
<li>每个进程被分配到的时间片的长度大致上是相等的</li>
<li>全部进程运行结束消耗的时间随着进程数量的增加而等比例地增加</li>
</ol>
<h4 id="图形实现"><a href="#图形实现" class="headerlink" title="图形实现"></a>图形实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]  <span class="comment"># 中文字体</span></span><br><span class="line"><span class="comment"># 数据处理和分组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_data</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.readlines()</span><br><span class="line">    process_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data[<span class="number">2</span>:]:</span><br><span class="line">        pid, time_passed, progress = <span class="built_in">map</span>(<span class="built_in">int</span>, line.strip().split(<span class="string">&#x27;\t&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> pid <span class="keyword">not</span> <span class="keyword">in</span> process_data:</span><br><span class="line">            process_data[pid] = &#123;<span class="string">&#x27;time&#x27;</span>: [], <span class="string">&#x27;progress&#x27;</span>: []&#125;</span><br><span class="line">        process_data[pid][<span class="string">&#x27;time&#x27;</span>].append(time_passed)</span><br><span class="line">        process_data[pid][<span class="string">&#x27;progress&#x27;</span>].append(progress)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> process_data</span><br><span class="line"><span class="comment"># 图一作图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_time_vs_process</span>(<span class="params">process_data, filename</span>):</span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))  <span class="comment"># 设置图的大小</span></span><br><span class="line">    <span class="keyword">for</span> pid, data <span class="keyword">in</span> process_data.items():</span><br><span class="line">        plt.scatter(data[<span class="string">&#x27;time&#x27;</span>], [pid] * <span class="built_in">len</span>(data[<span class="string">&#x27;time&#x27;</span>]), label=<span class="string">f&#x27;Process <span class="subst">&#123;pid&#125;</span>&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, s=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;时间 (ms)&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;进程 ID&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;在单核 CPU 上运行的进程&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.xlim(<span class="number">0</span>)  <span class="comment"># 将横轴的起始值设为0</span></span><br><span class="line">    plt.yticks(<span class="built_in">range</span>(<span class="built_in">len</span>(process_data)))  <span class="comment"># 设置纵坐标的刻度为 0 到最大进程数</span></span><br><span class="line">    plt.savefig(filename + <span class="string">&#x27;_1.png&#x27;</span>)  <span class="comment"># 保存图片</span></span><br><span class="line">    plt.close()</span><br><span class="line"><span class="comment"># 图二作图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_progress</span>(<span class="params">process_data, filename</span>):</span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))  <span class="comment"># 设置图的大小</span></span><br><span class="line">    <span class="keyword">for</span> pid, data <span class="keyword">in</span> process_data.items():</span><br><span class="line">        plt.scatter(data[<span class="string">&#x27;time&#x27;</span>], data[<span class="string">&#x27;progress&#x27;</span>], label=<span class="string">f&#x27;Process <span class="subst">&#123;pid&#125;</span>&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, s=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;时间 (ms)&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;进度 (%)&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;各进程的进度&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.xlim(<span class="number">0</span>)  <span class="comment"># 将横轴的起始值设为0</span></span><br><span class="line">    plt.yticks(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">101</span>, <span class="number">10</span>))  <span class="comment"># 设置纵坐标的刻度为 0 到 100，步长为 10</span></span><br><span class="line">    plt.savefig(filename + <span class="string">&#x27;_2.png&#x27;</span>)  <span class="comment"># 保存图片</span></span><br><span class="line">    plt.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_prefixes = [<span class="string">&#x27;1core-1process&#x27;</span>, <span class="string">&#x27;1core-2process&#x27;</span>, <span class="string">&#x27;1core-4process&#x27;</span>]  <span class="comment"># 三个数据文件的前缀名</span></span><br><span class="line">    <span class="keyword">for</span> prefix <span class="keyword">in</span> file_prefixes:</span><br><span class="line">        filename = prefix + <span class="string">&#x27;.txt&#x27;</span>  <span class="comment"># 请将文件名替换为实际的数据文件名</span></span><br><span class="line">        process_data = parse_data(filename)</span><br><span class="line"></span><br><span class="line">        plot_time_vs_process(process_data, filename)</span><br><span class="line">        plot_progress(process_data, filename)</span><br></pre></td></tr></table></figure>

<h3 id="进程状态查看"><a href="#进程状态查看" class="headerlink" title="进程状态查看"></a>进程状态查看</h3><p>进程一般有四种状态：</p>
<ol>
<li>运行态</li>
<li>就绪态 ——&gt; 具备运行条件，等待 CPU 分配时间</li>
<li>睡眠态 ——&gt; 不准备运行，除非发生某些时间，不占用 CPU 时间</li>
<li>僵死状态 ——&gt; 运行结束，等待父进程回收</li>
</ol>
<p>ps ax 查看进程状态。</p>
<img src="/2023/12/08/linux-%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/ps_ax.png" class="">

<p>STAT一栏一般有三种状态：</p>
<table>
<thead>
<tr>
<th align="center">首字母</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">R</td>
<td align="center">运行态或就绪态</td>
</tr>
<tr>
<td align="center">S 或 D</td>
<td align="center">睡眠态</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">僵死态</td>
</tr>
</tbody></table>
<p>S 可通过接收信号回到运行态，D 指 S 以外的情况（主要出现于等待外部存储器地访问时）</p>
<p>一般处于睡眠态的进程所等待的事件有几种：</p>
<ul>
<li>被要求等待指定的时间（比如 sleep 函数）</li>
<li>等待用户通过键盘或鼠标等设备输入</li>
<li>等待 SDD 或 HDD 等外部存储器的读写结束</li>
<li>等待网络的数据收发结束</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">teriteri@ubuntu:~/Desktop$ ps ax | wc -l</span><br><span class="line">281</span><br></pre></td></tr></table></figure>

<p>也可以直接查看进程总数。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#操作系统" >
    <span class="tag-code">操作系统</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
        <span class="nav-arrow">← </span>
        
          Pwn 学习笔记
        
      </a>
    
    
      <a class="nav-right" href="/2023/12/08/MIPS-%E5%AD%A6%E4%B9%A0/">
        
          MIPS 学习
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%B0%8F%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95"><span class="toc-nav-text">小实验记录</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-nav-text">系统调用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#strace-%E5%91%BD%E4%BB%A4"><span class="toc-nav-text">strace 命令</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sar-%E5%91%BD%E4%BB%A4"><span class="toc-nav-text">sar 命令</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ldd-%E5%91%BD%E4%BB%A4"><span class="toc-nav-text">ldd 命令</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-nav-text">进程管理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fork"><span class="toc-nav-text">fork()</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#execve"><span class="toc-nav-text">execve()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-nav-text">进程调度器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8D%95%E6%A0%B8%E5%BF%83%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E9%AA%8C"><span class="toc-nav-text">单核心多进程实验</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8D%95%E6%A0%B8%E5%8D%95%E8%BF%9B%E7%A8%8B"><span class="toc-nav-text">单核单进程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8D%95%E6%A0%B8%E5%8F%8C%E8%BF%9B%E7%A8%8B"><span class="toc-nav-text">单核双进程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8D%95%E6%A0%B8%E5%9B%9B%E8%BF%9B%E7%A8%8B"><span class="toc-nav-text">单核四进程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93"><span class="toc-nav-text">一些总结</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%9B%BE%E5%BD%A2%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">图形实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9F%A5%E7%9C%8B"><span class="toc-nav-text">进程状态查看</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2023/12/08/linux-基础实验/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>